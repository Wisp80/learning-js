'use strict';

/*-------------------------------------------------------------------------------------------------------------------*/

/*Можно создавать функции при помощи "new Function". В качестве параметров сначала передаются аргументы функции, а
последним параметром тело функции. Этот способ позволяет превратить любую строку в функцию.*/
let func01 = new Function('a', 'b', 'return a + b');
console.log(func01(1, 2)); // 3

let func02 = new Function('console.log(123)');
func02(); // 123

console.log('--------------------------------------');

/*-------------------------------------------------------------------------------------------------------------------*/

/*Когда функция создается с использованием "new Function", в ее "[[Environment]]" записывается ссылка не на внешнее 
лексическое окружение, в котором она была создана, а на глобальное. Поэтому такая функция имеет доступ только к 
глобальным переменным.*/
function func03() {
    let value = 123;
    let func04 = new Function('console.log(value)');
    // function func04() { console.log(value) };
    return func04;
};

// func03()(); // Uncaught ReferenceError: value is not defined

/*Эта особенность new Function выглядит странно, но оказывается очень полезной на практике.

Представьте, что нужно создать функцию из строки. Код этой функции неизвестен во время написания скрипта, а будет 
определен только в процессе выполнения. Мы можем получить код с сервера или с другого ресурса. Наша новая функция 
должна взаимодействовать с основным скриптом. 

Что если бы она имела доступ к внешним переменным? Проблема в том, что перед отправкой JavaScript-кода на реальные 
работающие проекты код сжимается с помощью минификатора – специальной программы, которая уменьшает размер кода, удаляя 
комментарии, лишние пробелы, и, что самое главное, локальным переменным даются укороченные имена. Например, если в 
функции объявляется переменная "let userName", то минификатор изменяет ее на "let a" (или другую букву, если она не 
занята) и изменяет ее везде. Обычно так делать безопасно, потому что переменная является локальной, и никто снаружи не 
имеет к ней доступ. И внутри функции минификатор заменяет каждое ее упоминание. Минификаторы достаточно умные. Они не 
просто осуществляют "тупой" поиск-замену, они анализируют структуру кода, и поэтому ничего не ломается.

Так что если бы даже "new Function" и имела доступ к внешним переменным, она не смогла бы найти переименованную 
переменную "userName".*/