'use strict';

/*-------------------------------------------------------------------------------------------------------------------*/

/*В JavaScript функции – это объекты. Функции можно не только вызывать, но и использовать их как обычные объекты: 
добавлять/удалять свойства, передавать их по ссылке и т.д.*/

/*Имя функции нам доступно как свойство "name".*/
function func01() { };
console.log(func01.name); // func01

/*Присваивает корректное имя даже в случае, когда функция создается без имени. В спецификации это называется 
"контекстное имя": если функция не имеет "name", то JavaScript пытается определить его из контекста.*/
let func02 = function () { };
console.log(func02.name); // func02

function func03(func04 = function () { }) {
    console.log(func04.name); // func04
};

func03();

/*Также имена имеют и методы объекта.*/
let obj01 = {
    method01: function () { }
};

console.log(obj01.method01.name); // method01

/*Бывает, что корректное имя определить невозможно. В таких случаях свойство "name" имеет пустое значение.*/
let arr01 = [function () { }];
console.log(arr01[0].name); // <empty string>

console.log('--------------------------------------');

/*-------------------------------------------------------------------------------------------------------------------*/

/*Еще одно встроенное свойство "length" содержит количество параметров функции в ее объявлении. Это позволяет 
использование Ad-hoc-полиморфизма – обработки аргументов в зависимости от их типа или, как в нашем случае – от значения 
свойства "length".*/
function func05(a, b, c, ...d) { };
console.log(func05.length); // 3, остаточные параметры не посчитались

console.log('--------------------------------------');

/*-------------------------------------------------------------------------------------------------------------------*/

/*Также можно добавить свои собственные свойства. В примере ниже основное отличие от использования замыкания состоит в
том, что если значение "a" живет во внешней переменной, то оно не доступно для внешнего кода. Изменить его могут только 
вложенные функции. А если оно присвоено как свойство функции, то мы можем его получить.*/
function func06() {
    let a = 0;
    console.log(a); // 0 -> 0
    console.log(func06.a); // 1 -> 2    
    func06.a++;
};

func06.a = 1;

func06();
func06();

console.log('--------------------------------------');

/*-------------------------------------------------------------------------------------------------------------------*/

/*Named Function Expression или NFE – это термин для Function Expression, у которого есть имя. Есть две важные 
особенности имени "func08":
1) Оно позволяет функции ссылаться на себя же.
2) Оно не доступно за пределами функции.*/

let func07 = function func08() {
    console.log(func07.name); // func08
    console.log(func08.name); // func08
};

func07();
// func08(); // Uncaught ReferenceError: func08 is not defined

let func09 = function func10(a) {
    if (a) {
        console.log(a);
    } else {
        func10(123);
    };
};

func09(1); // 1
func09(); // 123

let func11 = function (a) {
    if (a) {
        console.log(a);
    } else {
        func11(345);
    };
};

func11(3); // 3
func11(); // 345

let func12 = func11;
func11 = null;
// func12(); // Uncaught TypeError: func11 is not a function

let func13 = func09;
func09 = null;
func13(); // 123

/*Трюк с внутренним именем, описанный выше, работает только для Function Expression и не работает для Function 
Declaration. Для Function Declaration синтаксис не предусматривает возможность объявить дополнительное внутреннее имя.
Зачастую, когда нам нужно надежное внутреннее имя, стоит переписать Function Declaration на Named Function 
Expression.*/

console.log('--------------------------------------');

/*-------------------------------------------------------------------------------------------------------------------*/

function sum(a) { // 1
    let currentSum = a; // 1

    function f(b) { // 2 -> 3
        currentSum += b; // 1 + 2 = 3 -> 3 + 3 = 6
        return f;
    };

    f.toString = function () {
        return currentSum;
    };

    return f;
};

alert(sum(1)(2)(3)); // 6