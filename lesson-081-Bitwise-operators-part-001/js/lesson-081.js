'use strict';

/*-------------------------------------------------------------------------------------------------------------------*/

/*Побитовые операторы интерпретируют операнды как последовательность из 32 битов. Они производят операции, используя
двоичное представление числа, и возвращают новую последовательность из 32 бит (число) в качестве результата.*/

/*Побитовые операторы в JavaScript работают с 32-битными целыми числами в их двоичном представлении. Это представление
называется "32-битное целое со знаком, старшим битом слева и дополнением до двойки".*/

/*Старший бит слева - это научное название для самого обычного порядка записи цифр (от большего разряда к меньшему). 
При этом, если больший разряд отсутствует, то соответствующий бит равен нулю.*/
let a = 0; // 00000000000000000000000000000000
a = 1; // 00000000000000000000000000000001
a = 2; // 00000000000000000000000000000010
a = 3; // 00000000000000000000000000000011
a = 255; // 00000000000000000000000011111111

/*Дополнение до двойки - это название способа поддержки отрицательных чисел. Двоичный вид числа, обратного данному,
например, 5 и -5, получается путем обращения всех битов с прибавлением 1. То есть, нули заменяются на единицы, единицы
- на нули и к числу прибавляется 1. Получается внутреннее представление того же числа, но со знаком минус.

314:  00000000000000000000000100111010
      11111111111111111111111011000101
                                    +1
-314: 11111111111111111111111011000110

Принцип дополнения до двойки делит все двоичные представления на два множества: если крайний-левый бит равен 0 - число
положительное, если 1 - число отрицательное. Поэтому этот бит называется знаковым битом.*/

/*-------------------------------------------------------------------------------------------------------------------*/

/*Список операторов:

Оператор 	                            Использование	      Описание

Побитовое И (AND) 	                a & b 	            Ставит 1 на бит результата, для которого соответствующие биты операндов равны 1.
Побитовое ИЛИ (OR) 	                a | b 	            Ставит 1 на бит результата, для которого хотя бы один из соответствующих битов операндов равен 1.
Побитовое исключающее ИЛИ (XOR) 	    a ^ b 	            Ставит 1 на бит результата, для которого только один из соответствующих битов операндов равен 1 (но не оба).
Побитовое НЕ (NOT) 	                ~a 	            Заменяет каждый бит операнда на противоположный.
Левый сдвиг 	                      a << b 	            Сдвигает двоичное представление a на b битов влево, добавляя справа нули.
Правый сдвиг, переносящий знак 	    a >> b 	            Сдвигает двоичное представление a на b битов вправо, отбрасывая сдвигаемые биты.
Правый сдвиг с заполнением нулями 	    a >>> b 	      Сдвигает двоичное представление a на b битов вправо, отбрасывая сдвигаемые биты и добавляя нули слева.*/

/*Побитовые операторы работают следующим образом:

1) Операнды преобразуются в 32-битные целые числа, представленные последовательностью битов. Дробная часть, если она 
есть, отбрасывается.
2) Для бинарных операторов - каждый бит в первом операнде рассматривается вместе с соответствующим битом второго 
операнда: первый бит с первым, второй со вторым и так далее. Оператор применяется к каждой паре бит, давая 
соответствующий бит результата.
3) Получившаяся в результате последовательность бит интерпретируется как обычное число.*/

/*-------------------------------------------------------------------------------------------------------------------*/

/*& (Побитовое И) выполняет операцию И над каждой парой бит. Результат a & b равен единице только когда оба бита a и b
равны единице.*/

/*Таблица истинности для &:

a	b	a & b

0	0	  0
0	1	  0
1	0	  0
1	1	  1*/

/*
2    &  3
010  &  011

010
011
---
010 (2)
*/
console.log(2 & 3); // 2

console.log('--------------------------------------');

/*-------------------------------------------------------------------------------------------------------------------*/

/*| (Побитовое ИЛИ) выполняет операцию ИЛИ над каждой парой бит. Результат a | b равен 1, если хотя бы один бит из 
a, b равен 1.*/

/*Таблица истинности для |:

a	b	a | b
0	0	  0
0	1	  1
1	0	  1
1	1	  1*/

/*
2    |  3
010  |  011

010
011
---
011 (3)
*/
console.log(2 | 3); // 3

console.log('--------------------------------------');

/*-------------------------------------------------------------------------------------------------------------------*/

/*^ (Исключающее ИЛИ) выполняет операцию "Исключающее ИЛИ" над каждой парой бит. a Исключающее ИЛИ b равно 1, если 
только a=1 или только b=1, но не оба одновременно a=b=1.*/

/*Таблица истинности для исключающего ИЛИ:

a	b	a ^ b
0	0	  0
0	1	  1
1	0	  1
1	1	  0*/

/*
2    ^  3
010  ^  011

010
011
---
001 (1)
*/
console.log(2 ^ 3); // 1

console.log('--------------------------------------');

/*-------------------------------------------------------------------------------------------------------------------*/

/*~ (Побитовое НЕ) производит операцию НЕ над каждым битом, заменяя его на обратный ему.*/

/*Таблица истинности для НЕ:

a	~a
0	1
1	0*/

/*
~2
*/
console.log(~2); // -3

console.log('--------------------------------------');

/*-------------------------------------------------------------------------------------------------------------------*/

/*Операторы битового сдвига принимают два операнда. Первый - это число для сдвига, а второй - количество битов, которые
нужно сдвинуть в первом операнде.*/

/*-------------------------------------------------------------------------------------------------------------------*/

/*<< (Битовый сдвиг влево) сдвигает первый операнд на указанное число битов влево. Лишние биты отбрасываются, справа 
добавляются нулевые биты. Например, 9 << 2 даст 36:

9:      00000000000000000000000000001001 
9 << 2: 00000000000000000000000000100100

Битовый сдвиг << N обычно имеет тот же эффект, что и умножение на два N раз.*/
console.log(3 << 1); // 6, умножение на 2
console.log(3 << 2); // 12, умножение на 2 два раза
console.log(3 << 3); // 24, умножение на 2 три раза

/*-------------------------------------------------------------------------------------------------------------------*/

console.log('--------------------------------------');

/*>> (Правый битовый сдвиг, переносящий знак) сдвигает биты вправо, отбрасывая лишние. При этом слева добавляется копия
крайнего-левого бита. Знак числа (представленный крайним-левым битом) при этом не меняется, так как новый крайний-левый
бит имеет то же значение, что и в исходном числе. Поэтому он назван "переносящим знак". Например, 9 >> 2 даст 2:

9:      00000000000000000000000000001001
9 >> 2: 00000000000000000000000000000010

Битовый сдвиг >> N обычно имеет тот же результат, что и целочисленное деление на два N раз.*/
console.log(100 >> 1); // 50, деление на 2
console.log(100 >> 2); // 25, деление на 2 два раза
console.log(100 >> 3); // 12, деление на 2 три раза, целая часть от результата

/*-------------------------------------------------------------------------------------------------------------------*/

console.log('--------------------------------------');

/*>>> (Правый сдвиг с заполнением нулями) сдвигает биты первого операнда вправо. Лишние биты справа отбрасываются. 
Слева добавляются нулевые биты. Знаковый бит становится равным 0, поэтому результат всегда положителен. Для 
неотрицательных чисел правый сдвиг с заполнением нулями >>> и правый сдвиг с переносом знака >> дадут одинаковый 
результат, так как в обоих случаях слева добавятся нули. Для отрицательных чисел - результат работы разный. Например,
-9 >>> 2 даст 1073741821, в отличие от -9 >> 2 (дает -3):

-9:       11111111111111111111111111110111 
-9 >> 2:  11111111111111111111111111111101 
-9 >>> 2: 00111111111111111111111111111101*/

/*-------------------------------------------------------------------------------------------------------------------*/

/*В JavaScript побитовые операторы ^, &, | выполняются после сравнений ==. Например, в сравнении a == b^0 будет сначала
выполнено сравнение a == b, а потом уже операция ^0, как будто стоят скобки (a == b)^0. Чтобы гарантировать желаемый 
порядок, нужно ставить скобки: a == (b^0).*/

/*-------------------------------------------------------------------------------------------------------------------*/

/*Так как битовые операции отбрасывают десятичную часть, то их можно использовать для округления. Достаточно взять 
любую операцию, которая не меняет значение числа.*/
console.log(~~12.345); // 12
console.log(12.345 ^ 0); // 12
console.log(12.3 * 14.5 ^ 0); // 178
console.log(1.1 + 1.2 ^ 0); // 2

console.log('--------------------------------------');

/*-------------------------------------------------------------------------------------------------------------------*/

/*~n == 0 только если n == -1. Поэтому можно легко проверить равенство n == -1. Проверка на -1 пригождается, например,
при поиске символа в строке. Вызов метода "indexOf()" возвращает позицию подстроки в строке, или -1 если не нашел.*/
let str01 = 'abc';

if (~str01.indexOf('ab')) { console.log(1) }; // 1
if (~str01.indexOf('ad')) { console.log(2) };