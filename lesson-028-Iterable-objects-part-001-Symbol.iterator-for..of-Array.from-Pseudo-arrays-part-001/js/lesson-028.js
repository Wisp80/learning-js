'use strict';

/*-------------------------------------------------------------------------------------------------------------*/

/*Перебираемые (или итерируемые) объекты можно использовать в цикле "for..of". Строки также являются 
перебираемыми объектами.*/

let string0 = '14';
let array0 = [1, 4];
let obj0 = { a: 1, b: 4 };

for (const key in string0) {
    console.log(string0[key]); // '1' =>  '4'
};

for (const key in array0) {
    console.log(array0[key]); // 1 =>  4
};

for (const key in obj0) {
    console.log(obj0[key]); // 1 =>  4
};

for (const iterator of string0) {
    console.log(iterator); // '1' =>  '4'
};

for (const iterator of array0) {
    console.log(iterator); // 1 =>  4
};

// for (const iterator of obj0) { //  Uncaught TypeError: obj0 is not iterable
//     console.log(iterator);
// };

console.log('--------------------------------------');

/*-------------------------------------------------------------------------------------------------------------*/

/*Чтобы сделать объект итерируемым нужно добавить ему метод под свойством в виде специального встроенного 
символа "[Symbol.iterator]". Когда цикл "for..of" запускается, он вызывает этот метод один раз или же выдает 
ошибку, если этот метод не был найден. Этот метод должен вернуть итератор – объект с методом "next()". Дальше 
цикл "for..of" работает только с этим возвращенным объектом. Когда цикл "for..of" хочет получить следующее 
значение, он вызывает метод "next()" этого объекта. Результат вызова метода "next()" должен иметь вид: 
"{done: Boolean, value: any}", где свойство "done" со значением "true" означает, что цикл завершен, в противном 
случае свойство "value" содержит очередное значение.*/
let obj1 = {
    a: 1,
    b: 6
};

/*У самого объекта "obj1" нет метода "next()". Вместо этого другой объект, так называемый "итератор", создается 
вызовом "obj1[Symbol.iterator]()", и именно его метод "next()" генерирует значения. Таким образом, объект итератор 
отделен от самого итерируемого объекта.*/
obj1[Symbol.iterator] = function () {
    console.log('Symbol.iterator'); // вызовется только один раз.

    return {
        current: this.a, // 1 => 2 => 3 => 4 => 5 => 6 => 7
        last: this.b, // 6

        next() {
            console.log('next'); // вызовется 7 раз.

            if (this.current <= this.last) {
                return { done: false, value: this.current++ };
            } else {
                return { done: true };
            };
        }
    };
};

for (const num of obj1) {
    console.log(num); // 1 => 2 => 3 => 4 => 5 => 6
};

/*Пошаговая инструкция как сделать объект итериуремым:

1. Добавить в объект метод под символьным ключом "[Symbol.iterator]", который всегда должен возвращать 
объект, в котором в свою очередь должен быть всегда метод "next()". Разрешена дополнительная логика в 
методе "[Symbol.iterator]()" и объекте, которым будет возвращен этим методом.

2. Метод "next()" всегда должен возвращать один из двух объектов: {done: false, value: any value} или 
{done: true}. Первый объект будет говорить циклу "for..of", что работа цикла "for..of" еще не завершена 
(done: false) и нужно взять указанное значение в текущей итерации (value: any value). Второй объект будет 
говорить, что работа цикла "for..of" завершена (done: true) и никаких значений больше не надо получать. 
Разрешена дополнительная логика в методе "next()".

3. Когда цикл "for..of" начнет свою работу, он попытается вызвать один раз метод "[Symbol.iterator]()". Если 
такой метод будет в итерируемом объекте и этот метод вернет другой объект, в котором будет метод "next()", 
то после этого шага цикл "for..of" будет работать только с этим последним объектом, полученным от метода 
"[Symbol.iterator]()". 

4. Далее цикл "for..of" на первой итерации попробует вызвать метод "next()" в полученном от метода 
"[Symbol.iterator]()" объекте и в зависимости от полученного объекта от этого метода "next()" будет 
действовать дальше. Если будет получен объект типа {done: false, value: any value}, то будет передано какое-то 
значение для текущей итерации и запущен метод "next()" еще раз для запуска следующей итерации. Если же будет 
получен объект типа {done: true}, то цикл "for..of" завершит свою работу.

5. Как именно будет метод "next()" итерировать свойства перебираемого объекта зависит от программиста. Мы 
свободны в написании логики метода "next()", пока мы соблюдаем условие, что в конце своей работы этот метод 
возвращает один из двух объектов: {done: false, value: any value} или {done: true}. Например, выше наш объект 
имеет только два свойства, которые представляют собой границы диапозона чисел (от 1 до 6), и по нашей задумке 
мы хотим проитерировать по всем числам этого диапозона. Соответственно, наш метод "next()" на основе граничных 
чисел диапозона, должен сам воссоздать остальные числа этого диапозона (2, 3, 4, 5). Поэтому помимо указанного 
выше требования по возращению одного из двух объектов, мы реализовали в методе "next()" дополнительную логику 
по генерации остальных чисел диапозона. 

6. Также мы свободны в написании дополнительной логики в объекте, который будет возвращен от метода 
"[Symbol.iterator]()" при условии, что мы соблюдаем требование по наличию метода "next()" в этом объекте.

7. Если бы нам было это нужно, мы также могли бы добавить какую-то дополнительную логику и в метод 
"[Symbol.iterator]()" для достижения наших целей, естественно не забыв про обязательное требование, чтобы 
метод "[Symbol.iterator]()" возвращал объект с методом "next()".*/

console.log('--------------------------------------');

/*-------------------------------------------------------------------------------------------------------------*/

/*Можно указать метод "next()" изначально в самом объекте, но тогда мы не сможем использовать этот объект в двух 
параллельных циклах "for..of", так как у них будет общее текущее состояние итерации, потому что теперь существует
лишь один итератор – сам итерируемый объект, а не отдельно возвращенный объект методом "[Symbol.iterator]()".*/

let obj2 = {
    a: 5,
    b: 8,

    [Symbol.iterator]() {
        this.current = this.a;
        return this; // Вернется объект "obj2", но в нем изначально есть метод "next()".
    },

    next() {
        if (this.current <= this.b) {
            return { done: false, value: this.current++ };
        } else {
            return { done: true };
        };
    }
};

for (const num of obj2) {
    console.log(`------ OUTER ${num}`); // 5
    console.log(obj2.current); // 6

    for (const num of obj2) {
        console.log(`inner ${num}`); // 5 => 6 => 7 => 8
        console.log(obj2.current); // 6 => 7 => 8 => 9
    };
};

console.log('--------------------------------------');

/*-------------------------------------------------------------------------------------------------------------*/

/*Можно сделать бесконечный итератор, используя "Infinity". Или можно создать итерируемый объект, который 
генерирует бесконечную последовательность псевдослучайных чисел. Метод "next()" не имеет ограничений в этом 
плане. Всегда можем прервать цикл, используя "break".*/

/*-------------------------------------------------------------------------------------------------------------*/

/*Сделаем явный вызов итератора. Такой явный вызов может позволить нам настроить процесс итерации.*/
let string1 = 'ABCDE';
/*В изначально итерируемых данных присутствует объект-итератор. Получим ссыслку на него в отдельной переменной.*/
let iterator1 = string1[Symbol.iterator]();
/*Можно увидеть, что внутри объекта-итератора, есть метод "next()".*/
console.log(iterator1);

while (true) {
    /*Вручную сами запускаем метод "next()", как это делал бы, например, сам цикл "for..of".*/
    let result = iterator1.next();
    /*Можно увидеть, что метод "next()" будет возращать один из двух объектов: {done: false, value: any value} 
    или {done: true}.*/
    console.log(result);
    /*Обеспечиваем выход из цикла "while".*/
    if (result.done) break;
};

console.log('--------------------------------------');

/*-------------------------------------------------------------------------------------------------------------*/

/*Итерируемые объекты – это объекты, которые реализуют метод "[Symbol.iterator]()". Псевдомассивы – это объекты, 
у которых есть индексы и свойство "length", то есть, они выглядят как массивы. Строки это и то и то. Объекты выше 
это только итерируемые объекты, но не псевдомассивы. Но можно сделать объект, который является псевдомассивом, но 
его нельзя итерировать.*/
let obj3 = {
    0: 'a',
    1: 'b',
    length: 2
};

// for (const e of obj3) { console.log(e) }; // TypeError: obj3 is not iterable

/*-------------------------------------------------------------------------------------------------------------*/

/*И итерируемые объекты, и псевдомассивы – это обычно не массивы, у них нет методов "push()", "pop()" и так 
далее. Но есть метод "Array.from()", который принимает итерируемый объект или псевдомассив и делает из него 
"настоящий" массив.*/

/*Превратим псевдомассив в обычный массив.*/
let obj4 = {
    0: 'a',
    1: 'b',
    length: 2
};

let array1 = Array.from(obj4);
console.log(array1); // [ "a", "b" ]
console.log(array1.pop()); // 'b'

/*Превратим итерируемый объект в обычный массив.*/
let obj5 = {
    a: 1,
    b: 4
};

obj5[Symbol.iterator] = function () {
    return {
        current: this.a,
        last: this.b,

        next() {
            if (this.current <= this.last) {
                return { done: false, value: this.current++ };
            } else {
                return { done: true };
            };
        }
    };
};

let array2 = Array.from(obj5);
console.log(array2); // [ 1, 2, 3, 4 ]
console.log(array2.pop()); // 4

console.log('--------------------------------------');

/*-------------------------------------------------------------------------------------------------------------*/

/*Полный синтаксис метода "Array.from()" позволяет указать необязательную "трансформирующую" функцию в качестве 
второго параметра: "Array.from(obj[, mapFn, thisArg])". Второй необязательный параметр может быть функцией, 
которая будет применена к каждому элементу перед добавлением в массив. Также можно указать третий необязательный 
параметр "thisArg", который позволяет установить контекст "this" для этой функции.*/
let obj6 = {
    a: 1,
    b: 4
};

obj6[Symbol.iterator] = function () {
    return {
        current: this.a,
        last: this.b,

        next() {
            if (this.current <= this.last) {
                return { done: false, value: this.current++ };
            } else {
                return { done: true };
            };
        }
    };
};

let objThis = { c: 2 };

let array3 = Array.from(
    obj6,
    function (num) { return num * this.c },
    objThis
);

console.log(array3); // [ 1 * 2, 2 * 2, 3 * 2, 4 * 2 ] => [ 1, 4, 6, 8 ]

console.log('--------------------------------------');

/*-------------------------------------------------------------------------------------------------------------*/

/*Превратим строку в массив.*/
let string2 = 'ABCDE';
let array4 = Array.from(string2);
console.log(array4); // [ "A", "B", "C", "D", "E" ]

console.log('--------------------------------------');

/*-------------------------------------------------------------------------------------------------------------*/

/*Суррогатные пары это символы, которые записываются двумя 16-битными словами, поэтому их длина 2. Можно создать 
свою версию метода "slice()", которые может работать с суррогатными парами.*/
function slice(str, start, end) {
    return Array.from(str).slice(start, end).join('');
};

let string3 = '𝒳😂𩷶';
console.log(string3.length); // 6
console.log(Array.from(string3)); // [ "𝒳", "😂", "𩷶" ]

console.log(slice(string3, 1, 3)); // 😂𩷶

console.log(string3.slice(1, 3)); // �� (две части различных суррогатных пар)
console.log(string3.slice(2, 4)); // 😂
console.log(string3.slice(2, 7)); // 😂𩷶

console.log('--------------------------------------');

/*-------------------------------------------------------------------------------------------------------------*/

/*Сделаем итерируемый псевдомассив.*/
let obj7 = {
    0: 'A',
    1: 'B',
    2: function () {
        console.log(this);
    },

    length: 3,

    [Symbol.iterator]: function () {
        this.i = 0;
        console.log(this === obj6); // true, сам объект "obj7".
        console.log(this); // объект "obj7".
        return this; // Вернется объект "obj7", но в нем изначально есть метод "next()".
    },

    next: function () {
        console.log(this === obj6); // true

        if (this.i < this.length) {
            return { done: false, value: this[this.i++] };
        } else {
            return { done: true };
        };
    }
};

/*Расширим наш псевдомассив.*/
obj7['3'] = 'C';
obj7.length++;

for (const value of obj7) {
    console.log(value); // 'A' => 'B' => function 2() => 'C'
};

console.log('--------------------------------------');

/*-------------------------------------------------------------------------------------------------------------*/

/*Проитерируем объект, чтобы вывести весь английский алфавит.*/
let obj8 = {
    a: 'A',
    b: 'Z'
};

obj8[Symbol.iterator] = function () {
    return {
        a: this.a,
        b: this.b,
        currentCharCode: 0,

        next: function () {
            if (this.a <= this.b) {
                this.currentCharCode = this.a.codePointAt(0);
                this.a = String.fromCodePoint(this.currentCharCode + 1);
                return { done: false, value: String.fromCodePoint(this.currentCharCode++) };
            } else {
                return { done: true };
            };
        }
    };
};

for (const char of obj8) {
    console.log(char);
};