'use strict';

/*-------------------------------------------------------------------------------------------------------------------*/

/*Наследование классов – это способ расширения одного класса другим классом. Для наследования классов используется
ключевое слове "extends".*/
class Class01 {
    constructor() { this.a = 1 };
    method01() { console.log('aa'); };
};

class Class02 extends Class01 {
    method02() { console.log('bb'); };
};

console.log(Class01.prototype); // Object { constructor: class Class01 {};​ method01: function method01() }
console.log(Class02.prototype); // Object { constructor: class Class02 {};​ method02: function method02() }

let obj01 = new Class02(); // функция "constructor()" была вызвана из класса "Class01", так как у класса "Class02" такой функции указано не было
console.log(obj01); // Object { a: 1 }
obj01.method02(); // "bb"; obj01 => Class02.prototype
obj01.method01(); // "aa"; obj01 => Class02.prototype => Class01.prototype

console.log('--------------------------------------');

/*-------------------------------------------------------------------------------------------------------------------*/

/*Синтаксис создания класса допускает указывать после ключевого слова "extends" не только класс, но и любое 
выражение.*/

/*Создаем функцию "func01()", которая возвращает класс.*/
function func01(a) {
    return class {
        method01() { console.log(a); }
    };
};

/*Создаем класс "Class03", который будет наследоваться от класса, который будет возвращен функцией "func01()", когда
она будет вызвана.*/
class Class03 extends func01(123) { };
let obj02 = new Class03();
obj02.method01(); // 123, метод взят из объекта-прототипа класса-завещателя

console.log('--------------------------------------');

/*-------------------------------------------------------------------------------------------------------------------*/

/*При наследовании классов можно переопределить какой-то метод класса-завещателя в классе-наследнике. То есть можно в
классе-наследнике сделать метод, который будет работать как один из методов класса-завещателя, при этом имея какой-то
дополнительный функционал. Для этого у классов есть ключевое слово "super":
1) Вызов метода "super.method()" сделает вызов какого-то родительского метода.
2) Вызов метода "super()" вызовет родительскую функцию "constructor()" (работает только внутри функции "constructor()" 
у класса-наследника).*/
class Class04 {
    constructor() { this.a = 1 };
    method01() { console.log(45) };
};

class Class05 extends Class04 {
    constructor() {
        super();
        this.b = 2;
    };

    method01() {
        super.method01();
        console.log(67);
    };
};

let obj03 = new Class05;
console.log(obj03); // Object { a: 1, b: 2 }
obj03.method01(); // 45 => 67

console.log('--------------------------------------');

/*-------------------------------------------------------------------------------------------------------------------*/

/*У стрелочных функций нет ключевого слова "super". Стрелочные функции берут значение "super" из ближайшей внешней 
нестрелочной функции. Поэтому стрелочные функции "прозрачно" встраиваются во внешний контекст.*/
class Class06 {
    method01() { console.log(89) };
};

/*Здесь "super" в стрелочной функции "arrowFunc01()" тот же самый, что и в методе "method01()".*/
class Class07 extends Class06 {
    method01() {
        let arrowFunc01 = () => { super.method01() };
        arrowFunc01(); // 89
        super.method01(); // 89
        console.log(90);
    }
};

let obj04 = new Class07();
obj04.method01(); // 89 => 89 => 90

console.log('--------------------------------------');

/*-------------------------------------------------------------------------------------------------------------------*/

/*Согласно спецификации, если класс наследует другой класс и не имеет своей функции "constructor()", то в этом классе 
автоматически создается функция "constructor()", внутри которой вызывается функция "constructor()" класса-завещателя 
"super()". Но если мы все-таки укажем функцию "constructor()" в классе-наследника, при этом не укажем в этой функции
вызов функции "constructor()" класса-завещателя "super()", то будет ошибка.*/
class Class08 {
    constructor() { this.a = 1 };
    method01() { console.log('aa') };
};

class Class09 extends Class08 {
    // constructor() { this.b = 2 }; // Uncaught ReferenceError: must call super constructor before using 'this' in derived class constructor
    method02() { console.log('bb') };
};

let obj05 = new Class09();

/*Функции "constructor()" в классах-наследниках должны обязательно вызывать функцию "super()", и делать это перед 
использованием this.

В JavaScript существует различие между функциями "constructor()" классов-наследников и всеми остальными функциями 
"constructor()". В классе-наследнике соответствующая функция "constructor()" помечена специальным внутренним свойством 
" [[ConstructorKind]]:"derived" ", что обуславливает следующую разницу:
1) Когда выполняется обычная функция "constructor()", она создает пустой объект и присваивает его this.
2) Когда запускается функция "constructor()" класса-наследника, она этого не делает. Вместо этого она ждет, что это 
функция "constructor()" класса-завещателя.*/

console.log('--------------------------------------');

/*-------------------------------------------------------------------------------------------------------------------*/

/*Можно переопределять не только методы, но и поля класса.*/

/*Когда родительская функция "constructor()" вызывается в производном классе, она использует переопределенный метод.

Но в этом примере мы видим, что родительская функция "constructor()" использует свое собственное значение поля, а не 
переопределенное.

Причина этого заключается в порядке инициализации полей:
1) Поле класса инициализируется перед вызовом функции "constructor()" для класса-завещателя.
2) Поле класса инициализируется сразу после вызова функции "super()" для класса-наследника.*/
class Class10 {
    a = 1;
    method01() { console.log('aa') };

    constructor() {
        this.method01();
        console.log(this.a);
    };
};

class Class11 extends Class10 {
    a = 2;
    method01() { console.log('bb') };
};

/*Здесь сначала создается поле "a = 1" в классе-завещателе, затем запускается функция "constructor()" 
класса-завещателя.*/
let obj06 = new Class10(); // "aa" => 1

/*Здесь сначала запускается автоматически созданная функция "constructor()" в классе-наследнике, в которой вызывается 
функция "super()", которая в свою очередь запускает функцию "constructor()" класса-завещателя, у которого уже есть 
поле "a = 1", и только уже после этого создается поле "a = 2" в классе-наследнике.*/
let obj07 = new Class11(); // "bb" => 1

console.log(obj06); // Object { a: 1 }
console.log(obj07); // Object { a: 2 }

console.log('--------------------------------------');

/*-------------------------------------------------------------------------------------------------------------------*/

/*Пример как множественное переопределение работает в прототипном наследовании объектов с использованием this. В данном
случае использование this создает нам проблему в виде бесконечной рекурсии.*/
let obj08 = {
    name: 'Obj08',
    method01() { console.log(this.name) } // свойство "[[HomeObject]]" равно объекту "obj08"
};

let obj09 = {
    __proto__: obj08,
    name: 'Obj09',
    method01() { this.__proto__.method01.call(this) } // свойство "[[HomeObject]]" равно объекту "obj09"
};

let obj10 = {
    __proto__: obj09,
    name: 'Obj10',
    method01() { this.__proto__.method01.call(this) } // свойство "[[HomeObject]]" равно объекту "obj10"
};

// obj10.method01(); // Uncaught InternalError: too much recursion

// this.__proto__.method01 .call(this)
// obj10.__proto__.method01 .call(obj10)
// obj09.method01 .call(obj10)

// this.__proto__.method01 .call(this) .call(obj10)
// obj10.__proto__.method01 .call(obj10) .call(obj10)
// obj09.method01 .call(obj10) .call(obj10)

// this.__proto__.method01 .call(this) .call(obj10) .call(obj10)
// obj10.__proto__.method01 .call(obj10) .call(obj10) .call(obj10)
// obj09.method01 .call(obj10) .call(obj10) .call(obj10)

/*Когда мы вызываем функцию "super.method()", то движку необходимо получить этот метод из объекта-прототипа текущего 
объекта, который будет в this. Но если бы для этого использовался просто this, то мы получали бы такую же проблему как 
и в примере выше, то есть бесконечную рекурсию.*/
class Class12 {
    method01() { console.log('aa') }; // свойство "[[HomeObject]]" равно объекту "Class12"
};

class Class13 extends Class12 {
    method01() { // свойство "[[HomeObject]]" равно объекту "Class13"
        /*this в коде ниже отработает аналогично как и в примере выше, то есть создаст бесконечную рекурсию.*/
        // this.method01(); // Uncaught InternalError: too much recursion

        // obj11.method01()
        // obj11.__proto__.method01()
        // Class13.prototype.method01()

        // obj11.method01()
        // obj11.__proto__.method01()
        // Class13.prototype.method01()

        // obj11.method01()
        // obj11.__proto__.method01()
        // Class13.prototype.method01()

        /*-----------------------------------*/

        super.method01();

        // Class13.prototype.__proto__.method01()
        // Class12.prototype.method01()
        // console.log('aa')

        /*-----------------------------------*/

        console.log('bb');

        // console.log(super); // Uncaught SyntaxError: invalid use of keyword 'super'
    };
};

let obj11 = new Class13(); // { }
obj11.method01(); // "aa" => "bb"
console.log(' ');

/*Для решения этой проблемы в JavaScript было добавлено специальное внутреннее свойство для функций: "[[HomeObject]]".
Когда функция объявлена как метод внутри класса или объекта, то ее свойство "[[HomeObject]]" становится равным этому 
объекту. Затем ключевое слово "super" использует его, чтобы получить прототип родителя и его методы. Перепишем пример
с объектами выше, используя ключевое слово "super".*/
let obj12 = {
    name: 'Obj12',
    method01() { console.log(this.name) } // свойство "[[HomeObject]]" равно объекту "obj12"
};

let obj13 = {
    __proto__: obj12,
    name: 'Obj13',
    method01() { super.method01() } // свойство "[[HomeObject]]" равно объекту "obj13"
};

let obj14 = {
    __proto__: obj13,
    name: 'Obj14',
    method01() { super.method01() } // свойство "[[HomeObject]]" равно объекту "obj14"
};

obj14.method01(); // "Obj14"

// super.method01()
// obj14.__proto__.method01()
// obj13.method01()
// super.method01()
// obj13.__proto__.method01()
// obj12.method01()
// console.log(this.name)
// console.log(`${obj14.name}`)

console.log('--------------------------------------');

/*-------------------------------------------------------------------------------------------------------------------*/

/*"Обычные" функции в JavaScript "свободны", они не привязаны к объектам, их можно копировать между объектами и 
вызывать с любым this. Но само существование свойства "[[HomeObject]]" нарушает этот принцип, так как методы 
запоминают свои объекты, в которых они были созданы. Свойство "[[HomeObject]]" нельзя изменить, эта связь – навсегда.
То как это свойство работает напоминает как работает свойство "[[Environment]]" у функций.

Единственное место в языке, где используется свойство "[[HomeObject]]" – это ключевое слово "super". Поэтому если 
метод не использует ключевого слова "super", то мы все еще можем считать его свободным и копировать между объектами. А 
вот если ключевое слово "super" в коде есть, то возможны побочные эффекты.*/
let cat = {
    method01() { console.log('I am a cat') } // свойство "[[HomeObject]]" равно объекту "cat"
};

let Rex = {
    __proto__: cat,
    method01() { super.method01() } // свойство "[[HomeObject]]" равно объекту "Rex"
};

let human = {
    method01() { alert('I am a human') } // свойство "[[HomeObject]]" равно объекту "human"
};

let John = {
    __proto__: human,
    method01: Rex.method01
};

John.method01(); // "I am a cat"

console.log('--------------------------------------');

/*-------------------------------------------------------------------------------------------------------------------*/

/*Свойство "[[HomeObject]]" определено для методов как классов, так и обычных объектов. Но для объектов методы должны 
быть объявлены именно как "method()", а не "method: function()". В приведенном ниже примере используется синтаксис не 
метода, свойства-функции. Поэтому у него нет свойства "[[HomeObject]]", и наследование не работает.*/
let obj15 = {
    name: 'Obj15', // "свойство-значение-значение"
    method01: function () { this.name } // "свойство-значение-функция"
};

let obj16 = {
    __proto__: obj15,
    name: 'Obj16',
    // method01: function () { super.method01() } // "свойство-значение-функция", Uncaught SyntaxError: use of super property accesses only valid within methods or eval code within methods
    method01() { super.method01() } // "метод объекта", его свойство "[[HomeObject]]" равно объекту "obj16"
};

obj16.method01(); // "Obj16"