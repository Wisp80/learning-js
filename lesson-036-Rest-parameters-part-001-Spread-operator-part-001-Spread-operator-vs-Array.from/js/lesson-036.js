'use strict';

/*-------------------------------------------------------------------------------------------------------------------*/

/*Вызывать функцию можно с любым количеством аргументов независимо от того, как она была определена. Лишние аргументы 
не вызовут ошибку. Для передачи любого количества параметров можно использовать остаточные параметры. Остаточные 
параметры могут быть обозначены через три точки "...", что позволит собрать оставшиеся параметры и положить их в 
массив. Остаточные параметры должны располагаться в конце.*/
function func1(...args) {
    let sum = 0;
    for (let arg of args) sum += arg;
    return sum;
};

console.log(func1(1)); // 1
console.log(func1(1, 2)); // 3
console.log(func1(1, 2, 3)); // 6

/*Можно положить первые несколько параметров в переменные, а остальные – собрать в массив.*/
function func2(a, b, ...args) {
    console.log(a); // 1
    console.log(b); // 2
    console.log(args); // [ 3, 4, 5 ]
};

func2(1, 2, 3, 4, 5);

console.log('--------------------------------------');

/*-------------------------------------------------------------------------------------------------------------------*/

/*Все аргументы функции находятся в псевдомассиве "arguments" под своими порядковыми номерами. Поскольку "argument"
является псевдомассом, он не поддерживает методы массивов. Также "arguments" всегда содержит все аргументы функции,
поэтому мы не можем получить их часть. А остаточные параметры позволяют это сделать.*/
function func3() {
    console.log(arguments);
};

func3('a', 'b', 'c');

console.log('--------------------------------------');

/*-------------------------------------------------------------------------------------------------------------------*/

/*Стрелочные функции не имеют псевдомассива "arguments". Если мы обратимся к "arguments" из стрелочной функции, то 
получим аргументы внешней нестрелочной функции.*/
function func4() {
    let arrowFunc = () => console.log(arguments);
    arrowFunc(2);
};

func4(1); // 1

console.log('--------------------------------------');

/*-------------------------------------------------------------------------------------------------------------------*/

/*Существует также способ получить обратно список параметров из массива. Для этого нам поможет оператор расширения. Он 
похож на остаточные параметры – тоже использует "...", но делает совершенно противоположное. Когда перебираемый объект 
"...arr" используется при вызове функции, он "расширяет" (spread) перебираемый объект "arr" в список аргументов.*/
let array1 = [3, 1, 4];
let array2 = [2, 5, 3];
console.log(Math.max(...array1)); // 4

/*Этим же способом мы можем передать несколько итерируемых объектов.*/
console.log(Math.max(...array1, ...array2)); // 5

/*Мы даже можем комбинировать оператор расширения с обычными значениями.*/
console.log(Math.max(...array1, 0, ...array2, 7)); // 7

/*Оператор расширения подойдет для того, чтобы превратить строку в массив символов. Под капотом оператор расширения 
использует итераторы, чтобы перебирать элементы. Так же, как это делает цикл "for..of". Цикл "for..of" перебирает 
строку как последовательность символов, поэтому из "...str1" получается "H", "e", "l", "l", "o". Получившиеся символы 
собираются в массив при помощи стандартного объявления массива: [...str1]. Для этой задачи мы можем использовать и
метод "Array.from()". Он тоже преобразует перебираемый объект в массив.*/
let str1 = 'Hello';
console.log([...str1]); // Array(5) [ "H", "e", "l", "l", "o" ]
console.log(Array.from(str1)); // Array(5) [ "H", "e", "l", "l", "o" ]

/*Но между "Array.from(obj)" и [...obj] есть разница:
1) "Array.from()" работает как с псевдомассивами, так и с итерируемыми объектами.
2) Оператор расширения работает только с итерируемыми объектами.*/