'use strict';

/*-------------------------------------------------------------------------------------------------------------*/

/*JSON (JavaScript Object Notation) – это общий формат для представления значений и объектов. Его описание 
задокументировано в стандарте RFC 4627.*/

/*JavaScript предоставляет методы:
1) "JSON.stringify()" для преобразования объектов в JSON.
2) "JSON.parse()" для преобразования JSON обратно в объект.*/

let obj01 = {
    a: 'a',
    b: 2,
    c: false,
    d: ['x', 'y', 'z'],
    e: null
};

/*Метод "JSON.stringify()" берет объект и преобразует его в строку. Полученная строка json называется 
JSON-форматированным или сериализованным объектом. Мы можем отправить его по сети или поместить в обычное 
хранилище данных. Объект в формате JSON для строк и для имен свойств используют двойные кавычки.*/
console.log(JSON.stringify(obj01)); // "{"a":"a","b":2,"c":false,"d":["x","y","z"],"e":null}"
console.log(typeof JSON.stringify(obj01)); // string

console.log('--------------------------------------');

/*-------------------------------------------------------------------------------------------------------------*/

/*JSON поддерживает следующие типы данных:
1) Объекты.
2) Массивы.
3) Примитивы:
    a) строки,
    b) числа,
    c) логические значения true/false,
    d) null.*/

console.log(JSON.stringify(['a', 'v', 'V']));
console.log(JSON.stringify('rock'));
console.log(JSON.stringify(315));
console.log(JSON.stringify(false));
console.log(JSON.stringify(null));

console.log('--------------------------------------');

/*-------------------------------------------------------------------------------------------------------------*/

/*"JSON.stringify()" пропускает некоторые специфические свойства объектов JavaScript:

1) Свойства-функции (методы).
2) Символьные ключи и значения.
3) Свойства, содержащие undefined.*/

let symbol01 = Symbol('b');

let obj02 = {
    a: function () { },
    [symbol01]: 2,
    c: undefined
};

/*Форматы, которые не поддерживает JSON, возвращают undefined.*/
console.log(JSON.stringify(function () { })); // undefined
console.log(JSON.stringify(symbol01)); // undefined

console.log(JSON.stringify(obj02)); // {}

console.log(JSON.stringify(obj02.a)); // undefined
console.log(JSON.stringify(obj02[symbol01])); // 2
console.log(JSON.stringify(obj02.c)); // undefined
console.log(JSON.stringify(undefined)); // undefined

console.log('--------------------------------------');

/*-------------------------------------------------------------------------------------------------------------*/

/*Вложенные объекты поддерживаются и конвертируются автоматически.*/
let obj03 = {
    a: 1,
    b: {
        c: 2,
        d: [3, 4, 5]
    }
};

console.log(JSON.stringify(obj03)); // {"a":1,"b":{"c":2,"d":[3,4,5]}}

console.log('--------------------------------------');

/*-------------------------------------------------------------------------------------------------------------*/

/*При преобразовании в JSON не должно быть циклических ссылок.*/
let obj04 = { a: 1 };
let obj05 = { b: 2 };
obj04.c = obj05;
obj05.d = obj04;

console.log(obj04);
console.log(obj05);
// console.log(JSON.stringify(obj04)); // Uncaught TypeError: cyclic object value
// console.log(JSON.stringify(obj05)); // Uncaught TypeError: cyclic object value

console.log('--------------------------------------');

/*-------------------------------------------------------------------------------------------------------------*/

/*Метод "JSON.stringify()" имеет два дополнительных параметра: "replacer" и "space". "Replacer" это массив 
свойств для кодирования или функция соответствия по типу "function(key, value)". "Space" это дополнительное 
пространство (отступы), используемое для форматирования.*/

/*Если вторым параметром передать массив свойств в метод "JSON.stringify()", то будут закодированы только эти 
свойства.*/
let obj06 = { a: 'a' };

let obj07 = {
    b: 'b',
    c: [{ cc: 'c1' }, { cc: 'c2' }],
    d: obj06
};

obj06.e = obj07;

/*Список свойств применяется ко всей структуре объекта. Так что внутри свойства "c" – пустые объекты, потому что 
свойства "cc" нет в списке.*/
console.log(JSON.stringify(obj07, ['b', 'c'])); // "{"b":"b","c":[{},{}]}"
/*Включим остальные свойства, что все, кроме свойства "e" из объекта "obj06", было сериализовано.*/
console.log(JSON.stringify(obj07, ['b', 'c', 'd', 'cc', 'a'])); 
// "{"b":"b","c":[{"cc":"c1"},{"cc":"c2"}],"d":{"a":"a"}}"

/*Если вторым параметром передать функцию в метод "JSON.stringify()", то эта функция будет вызываться для каждой 
пары ключ/значение, и она будет должна возвращать замененное значение, которое будет использоваться вместо 
исходного, или undefined, чтобы пропустить значение. Эта функция получает каждую пару ключ/значение, включая 
вложенные объекты и элементы массива. И она применяется рекурсивно. Значение "this" внутри этой функции – 
это объект, который содержит текущее свойство.*/
console.log(
    JSON.stringify(
        obj07,

        function replacer(key, value) {
            console.log(`${key}: ${value}`);
            return (key === 'e') ? undefined : value;
        }
    )
); //  "{"b":"b","c":[{"cc":"c1"},{"cc":"c2"}],"d":{"a":"a"}}"

/*Первому вызову передается специальный "объект-обертка": { "": obj07 }. То есть первая пара (key, value) имеет 
пустой ключ, а значением является целевой объект в общем. Вот почему первая строка из примера выше будет 
":[object Object]". Благодаря этому можно сделать, чтобы была возможность проанализировать и 
заменить/пропустить даже весь объект целиком, если это необходимо.*/

console.log('--------------------------------------');

/*-------------------------------------------------------------------------------------------------------------*/

/*Третий аргумент в метода "JSON.stringify()" – это количество пробелов, используемых для удобного 
форматирования. Параметр "space" применяется исключительно для логирования и красивого вывода.*/
let obj08 = {
    b: 'b',
    c: [{ cc: 'c1' }, { cc: 'c2' }],
};

console.log(JSON.stringify(obj08, null, 2)); // отступ в 2 пробела
// {
//   "b": "b",
//   "c": [
//     {
//       "cc": "c1"
//     },
//     {
//       "cc": "c2"
//     }
//   ]
// }

/*Третьим аргументом также может быть строка. В этом случае строка будет использоваться для отступа вместо ряда 
пробелов.*/
console.log(JSON.stringify(obj08, null, '↕↕↕↕'));
// {
// ↕↕↕↕"b": "b",
// ↕↕↕↕"c": [
// ↕↕↕↕↕↕↕↕{
// ↕↕↕↕↕↕↕↕↕↕↕↕"cc": "c1"
// ↕↕↕↕↕↕↕↕},
// ↕↕↕↕↕↕↕↕{
// ↕↕↕↕↕↕↕↕↕↕↕↕"cc": "c2"
// ↕↕↕↕↕↕↕↕}
// ↕↕↕↕]
// }

console.log('--------------------------------------');

/*-------------------------------------------------------------------------------------------------------------*/

/*Как и метод "toString()" для преобразования строк, объект может предоставлять метод "toJSON()" для 
преобразования в JSON. Метод "JSON.stringify()" автоматически вызывает его, если он есть.*/
let obj09 = { a: 1 };
let obj10 = { b: 2, obj09};
// let obj10 = { b: 2, obj09: obj09 };

console.log(JSON.stringify(obj09)); // "{"a":1}"
console.log(JSON.stringify(obj10)); // "{"b":2,"obj09":{"a":1}}"

obj09.toJSON = function (key) {
    console.log('key is ' + key);
    return this.a
};

/*Метод "toJSON()" используется как при прямом вызове метод "JSON.stringify()", так и когда объект "obj09" вложен 
в другой сериализуемый объект.*/
console.log(JSON.stringify(obj09)); // "1"
console.log(JSON.stringify(obj10)); // "{"b":2,"obj09":1}" // {"b":2,"obj09":1}