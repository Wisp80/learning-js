'use strict';

/*-------------------------------------------------------------------------------------------------------------------*/

/*В процессе выполнения задачи в теле функции могут быть вызваны другие функции для выполнения подзадач. Частный случай
подвызова это когда функция вызывает сама себя. Это называется рекурсией.*/

/*Напишем функцию, которая возводит число в степень, не используя рекурсию.*/
function powWithoutRecursion(x, n) {
    let result = x; // 2

    for (let i = 1; i < n; i++) {
        result = result * x; // 2 * 2 = 4 => 4 * 2 = 8 => 8 * 2 => 16
    };

    return result;
};

console.log(powWithoutRecursion(2, 4)); // 16

/*Напишем функцию, которая возводит число в степень, используя рекурсию.*/
function powWithRecursion(x, n) {
    if (n === 1) { // Это базовый случай рекурсии или база рекурсии.
        return x;
    } else { // Это рекурсивный случай рекурсии или шаг рекурсии.
        return x * powWithRecursion(x, n - 1);
    };
};

console.log(powWithRecursion(2, 4)); // 16

/*Разберем работу функции с рекурсией:

Базовый случай в рекурсивной функции - это часть функции, в которой описывается условие прекращения работы функции в 
целях предотвращения зацикливания. То есть при создании рекурсии всегда должен быть базовый случай рекурсии, иначе 
рекурсия будет бесконечной.

Рекурсивный случай в рекурсивной функции - это часть функции, в которой функция вызывает сама себя в целях выполнения 
какой-либо задачи. Обычно с каждым новым таким вызовом функции задача упрощается. 

1. Вызывается функция "powWithRecursion()" первый раз с параметрами 2 и 4.
2. Внутри этого первого вызова первый блок "if" пропускается и происходит второй вызов функции с параметрами 2 и 3.
3. Во втором вызове функции опять первый блок "if" пропускается и происходит третий вызов функции с параметрами 2 и 2.
4. В третьем вызове функции опять первый блок "if" пропускается и происходит четвертый вызов функции с параметрами 2 и 1.
5. В четвертом вызове функции первый блок "if" уже не пропускается и четвертый вызов функции возращает третьему вызову 
функции значение 2, после чего четвертый вызов функции завершает свою работу.

6. Третий вызов функции получает это значение 2, умножает его на "x", (то есть на 2), получает 4, а далее возвращает 
второму вызову функции значение 4, после чего третий вызов функции завершает свою работу.
7. Второй вызов функции получает это значение 4, умножает его на "x", (то есть на 2), получает 8, а далее возвращает 
первому вызову функции значение 8, после чего второй вызов функции завершает свою работу.
8. Первый вызов функции получает это значение 8, умножает его на "x", (то есть на 2), получает 16, а далее возвращает 
"наружу" значение 16, после чего первый вызов функции завершает свою работу.

Порядок вызовов функции "powWithRecursion()" кратко можно записать так:
1) pow(2, 4) = 2 * pow(2, 3)
2) pow(2, 3) = 2 * pow(2, 2)
3) pow(2, 2) = 2 * pow(2, 1)
4) pow(2, 1) = 2

Как мы видим каждый шаг рекурсии наша задача упрощается: каждый раз степень становится на 1 меньше.

Общее количество вложенных вызовов (включая первый) называют глубиной рекурсии. В нашем случае она будет равна "n".*/

/*Максимальная глубина рекурсии ограничена движком JavaScript. Точно можно рассчитывать на 10000 вложенных вызовов, 
некоторые интерпретаторы допускают и больше, но для большинства из них 100000 вызовов – за пределами возможностей. 
Существуют автоматические оптимизации, помогающие избежать переполнения стека вызовов ("оптимизация хвостовой рекурсии"), 
но они ещё не поддерживаются везде и работают только для простых случаев.*/

console.log('--------------------------------------');

/*-------------------------------------------------------------------------------------------------------------------*/

/*Функции с рекурсией сверху можно записать короче, используя тернарное выражение.*/
function powWithRecursion2(x, n) {
    return (n === 1) ? x : (x * powWithRecursion2(x, n - 1));
};

// let powWithRecursion2 = (x, n) => (n === 1) ? x : (x * powWithRecursion2(x, n - 1));

console.log(powWithRecursion2(2, 4)); // 16