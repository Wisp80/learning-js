'use strict';

/*-------------------------------------------------------------------------------------------------------------------*/

/*Объект "Proxy" "оборачивается" вокруг другого объекта и может перехватывать (и, при желании, самостоятельно 
обрабатывать) разные действия с ним. Для создания такого объекта нужно использовать конструктор "new Proxy", у которого
первым параметром нужно указать объект для оборачивания, а вторым параметром - конфигурацию прокси, то есть объект с
"ловушками" ("traps"): методами, которые перехватывают разные операции, например, ловушка "get" - для чтения свойства
из оборачиваемого объекта, ловушка "set" - для записи свойства в этот объект и так далее.

При операциях над прокси, если имеется соответствующая ловушка, то она срабатывает, и прокси имеет возможность 
по-своему обработать ее, иначе операция будет совершена над оригинальным объектом.*/

/*Сделаем пример прокси без ловушек. Так как нет ловушек, то все операции на прокси применяются к оригинальному
объекту "obj01".*/
let obj01 = {};
let proxy01 = new Proxy(obj01, {});
console.log(proxy01); // Proxy { <target>: {}, <handler>: {} }

proxy01.a = 1;
console.log(obj01); // Object { a: 1 }
console.log(obj01.a); // 1
console.log(proxy01.a); // 1, взято из объекта "obj01"

console.log(proxy01); // Proxy { <target>: { a: 1 }, <handler>: {} }
for (let key in proxy01) { console.log(key) }; // "a", проитерировались по объекту "obj01"

/*Прокси - это особый, "экзотический", объект, у него нет собственных свойств. С пустым вторым параметром он просто 
перенаправляет все операции на оригинальный объект.*/

console.log('--------------------------------------');

/*-------------------------------------------------------------------------------------------------------------------*/

/*Для большинства действий с объектами в спецификации JavaScript есть так называемый "внутренний метод", который на 
самом низком уровне описывает, как его выполнять. Например, "[[Get]]" - внутренний метод для чтения свойства, "[[Set]]"
- для записи свойства, и так далее. Эти методы используются только в спецификации, мы не можем обратиться напрямую к 
ним по имени.

Ловушки как раз перехватывают вызовы этих внутренних методов.*/

/*Внутренний метод 	    Ловушка 	                Что вызывает

[[Get]] 	            get 	                    чтение свойства
[[Set]] 	            set 	                    запись свойства
[[HasProperty]] 	    has 	                    оператор in
[[Delete]] 	            deleteProperty 	            оператор delete
[[Call]] 	            apply 	                    вызов функции
[[Construct]] 	        construct 	                оператор new
[[GetPrototypeOf]] 	    getPrototypeOf 	            Object.getPrototypeOf
[[SetPrototypeOf]] 	    setPrototypeOf 	            Object.setPrototypeOf
[[IsExtensible]] 	    isExtensible 	            Object.isExtensible
[[PreventExtensions]] 	preventExtensions 	        Object.preventExtensions
[[DefineOwnProperty]] 	defineProperty 	            Object.defineProperty, Object.defineProperties
[[GetOwnProperty]] 	    getOwnPropertyDescriptor 	Object.getOwnPropertyDescriptor, for..in, Object.keys/values/entries
[[OwnPropertyKeys]] 	ownKeys 	                Object.getOwnPropertyNames, Object.getOwnPropertySymbols, for..in, Object.keys/values/entries*/

/*JavaScript налагает некоторые условия - инварианты на реализацию внутренних методов и ловушек. Большинство из них 
касаются возвращаемых значений:
1) Метод "[[Set]]" должен возвращать true, если значение было успешно записано, иначе false.
2) Метод "[[Delete]]" должен возвращать true, если значение было успешно удалено, иначе false.
3) И так далее.

Есть и другие инварианты, например, метод "[[GetPrototypeOf]]", примененный к прокси, должен возвращать то же значение, 
что и метод "[[GetPrototypeOf]]", примененный к оригинальному объекту. Другими словами, чтение прототипа объекта прокси 
всегда должно возвращать прототип оригинального объекта.

Ловушки могут перехватывать вызовы этих методов, но должны выполнять указанные условия. Инварианты гарантируют 
корректное и последовательное поведение конструкций и методов языка.*/

/*-------------------------------------------------------------------------------------------------------------------*/

/*Чтобы перехватить операцию чтения, второй параметр должен иметь метод "get(target, property, receiver)". Он 
срабатывает при попытке прочитать свойство объекта, с аргументами:
1) "target" - это оригинальный объект, который передавался первым аргументом в конструктор "new Proxy",
2) "property" - имя свойства,
3) "receiver" - если свойство объекта является геттером, то "receiver" - это объект, который будет использован как this 
при его вызове. Обычно это сам объект прокси (или наследующий от него объект).*/
let array01 = [1, 2, 3];

let proxy02 = new Proxy(array01, {
    get(target, property) {

        if (property in target) {
            return target[property];
        } else {
            return 0;
        };

    }
});

console.log(array01[1]); // 2
console.log(proxy02[1]); // 2
console.log(array01[5]); // undefined
console.log(proxy02[5]); // 0

console.log('--------------------------------------');

/*-------------------------------------------------------------------------------------------------------------------*/

/*Прокси следует использовать везде вместо оригинального объекта. Прокси должен заменить собой оригинальный объект 
повсюду. Никто не должен ссылаться на оригинальный объект после того, как он был проксирован. Иначе очень легко 
запутаться.*/

/*-------------------------------------------------------------------------------------------------------------------*/

/*Ловушка "set(target, property, value, receiver)" срабатывает, когда происходит запись свойства:
1) "target" - это оригинальный объект, который передавался первым аргументом в конструктор "new Proxy",
2) "property" - имя свойства,
3) "value" - значение свойства,
4) "receiver" - аналогично ловушке "get", этот аргумент имеет значение, только если свойство - сеттер.

Ловушка "set" должна вернуть true, если запись прошла успешно, и false в противном случае (будет сгенерирована ошибка
TypeError).*/
let array02 = [4, 5, 6];

array02 = new Proxy(array02, {
    set(target, property, value) {

        if (typeof value === 'number') {
            target[property] = value;
            return true;
        } else {
            return false;
        };

    }
});

array02.push(7);
array02.push(8);
console.log(array02.length); // 5
// array02.push('9'); // Uncaught TypeError: proxy set handler returned false for property '5'

console.log('--------------------------------------');

/*-------------------------------------------------------------------------------------------------------------------*/

/*Цикл "for..in" и большинство других методов, которые работают со списком свойств объекта, используют внутренний метод
"[[OwnPropertyKeys]]" (перехватываемый ловушкой "ownKeys") для их получения.*/
let obj02 = {
    a: 7,
    b: 8,
    _c: 9
};

obj02 = new Proxy(obj02, {

    ownKeys(target) {
        return Object.keys(target).filter(key => !key.startsWith('_'));
    }

});

for (let key in obj02) { console.log(key) }; // 'a' -> 'b'

/*Если мы попробуем возвратить ключ, которого в объекте на самом деле нет, то метод "Object.keys()" его не выдаст. 
Метод "Object.keys()" возвращает только свойства с флагом "enumerable". Для того, чтобы определить, есть ли этот флаг,
он для каждого свойства вызывает внутренний метод "[[GetOwnProperty]]", который получает его дескриптор. А в данном 
случае свойство отсутствует, его дескриптор пуст, флага "enumerable" нет, поэтому оно пропускается.*/
let obj03 = {};

obj03 = new Proxy(obj03, {

    ownKeys(target) {
        return ['10'];
    }

});

console.log(Object.keys(obj03)); // []

/*Чтобы метод "Object.keys()" возвращал свойство, нужно либо чтобы свойство в объекте физически было, причем с флагом 
"enumerable", либо перехватить вызовы "[[GetOwnProperty]]" (это делает ловушка "getOwnPropertyDescriptor"), и там 
вернуть дескриптор с "enumerable: true".*/
let obj04 = {};

obj04 = new Proxy(obj04, {

    ownKeys(target) { // Вызывается 1 раз для получения списка свойств.
        return ['11'];
    },

    getOwnPropertyDescriptor(target, property) { // Вызывается для каждого свойства.
        return {
            enumerable: true,
            configurable: true
        };
    }

});

console.log(Object.keys(obj04)); // [ "11" ]

console.log('--------------------------------------');

/*-------------------------------------------------------------------------------------------------------------------*/

/*Применим прокси, чтобы защитить свойства, начинающиеся на "_", от доступа извне.

Нам будут нужны следующие ловушки:
1) "get" - для того, чтобы сгенерировать ошибку при чтении такого свойства.
2) "set" - для того, чтобы сгенерировать ошибку при записи.
3) "deleteProperty" - для того, чтобы сгенерировать ошибку при удалении.
4) "ownKeys" - для того, чтобы исключить такие свойства из цикла "for..in" и методов типа "Object.keys()".*/
let obj05 = {
    a: 12,
    _b: 13,

    doSomething01: function () {
        console.log(this._b);
    }
};

obj05 = new Proxy(obj05, {

    get(target, property) {

        if (property.startsWith('_')) {
            throw new Error('Nope');
        } else {
            let value = target[property];
            /*Если внутри объекта будет метод, которому нужно будет свойство, начинающееся на "_", то при вызове такого
            метода ("obj05.doSomething01()") он получит проксированный объект "obj05" в качестве this (объект перед 
            точкой становится this), ловушка get вступает в действие (она срабатывает при любом чтении свойства), и 
            выбрасывается ошибка.
            
            Поэтому мы привязываем контекст к методам объекта - оригинальный объект "target". Тогда их дальнейшие 
            вызовы будут использовать "target" в качестве this, без всяких ловушек. Такое решение обычно работает, но 
            не является идеальным, поскольку метод может передать оригинальный объект куда-то еще, и возможна путаница:
            где изначальный объект, а где - проксированный. К тому же, объект может проксироваться несколько раз, и 
            если передавать методу исходный, то могут быть неожиданности.*/
            return (typeof value === 'function') ? value.bind(target) : value;
            // return value;
        };

    },

    set(target, property, value) { // Перехватываем запись свойства.

        if (property.startsWith('_')) {
            throw new Error('Nope');
        } else {
            target[property] = value;
            return true;
        };

    },

    deleteProperty(target, property) { // Перехватываем удаление свойства.

        if (property.startsWith('_')) {
            throw new Error('Nope');
        } else {
            delete target[property];
            return true;
        };

    },

    ownKeys(target) { // Перехватываем попытку итерации.
        return Object.keys(target).filter(key => !key.startsWith('_'));
    }

});

try {
    console.log(obj05._b);
} catch (e) {
    console.log(e.message); // 'Nope'
};

try {
    obj05._b = 14;
} catch (e) {
    console.log(e.message); // 'Nope'
};

try {
    delete obj05._b;
} catch (e) {
    console.log(e.message); // 'Nope'
};

for (let key in obj05) { console.log(key) }; // 'a' -> 'doSomething01'

obj05.doSomething01(); // 13

console.log('--------------------------------------');

/*-------------------------------------------------------------------------------------------------------------------*/

/*Ловушка "has" перехватывает вызовы "in". Эта ловушка имеет следующие параметры:
1) "target" - это оригинальный объект, который передавался первым аргументом в конструктор "new Proxy",
2) "property" - имя свойства.*/

let obj06 = {
    a: 1,
    b: 5
};

obj06 = new Proxy(obj06, {

    has(target, property) {
        return property >= target.a && property <= target.b;
    }

});

console.log(0 in obj06); // false
console.log(2 in obj06); // true
console.log(5 in obj06); // true
console.log(7 in obj06); // false

console.log('--------------------------------------');

/*-------------------------------------------------------------------------------------------------------------------*/

/*Ловушка "apply(target, thisArg, args)" активируется при вызове прокси как функции:
1) "target" - это оригинальный объект.
2) "thisArg" - это контекст this.
3) "args" - список аргументов.*/

/*Сделаем декоратор, который добавляет задержку.*/
function funcDecorator01(f, ms) {
    return new Proxy(f, {

        apply(target, thisArg, args) {
            setTimeout(() => target.apply(thisArg, args), ms);
        }

    });
};

function func01(a) { console.log(a) };

func01 = funcDecorator01(func01, 1000);

/*Другие операции на прокси перенаправляются к оригинальной функции.*/
console.log(func01.length); // 1
func01(15); // 15, через 1 секунду

console.log('--------------------------------------');

/*-------------------------------------------------------------------------------------------------------------------*/

/*"Reflect" - это встроенный объект, упрощающий создание прокси. Внутренние методы, такие как "[[Get]]", "[[Set]]" и 
другие, существуют только в спецификации и к ним нельзя обратиться напрямую. Объект "Reflect" делает это возможным. Его
методы - минимальные обертки вокруг внутренних методов. Вот примеры операций и вызовы "Reflect", которые делают то же 
самое:

Операция 	        Вызов Reflect 	                    Внутренний метод

obj[prop] 	        Reflect.get(obj, prop) 	            [[Get]]
obj[prop] = value 	Reflect.set(obj, prop, value) 	    [[Set]]
delete obj[prop] 	Reflect.deleteProperty(obj, prop) 	[[Delete]]
new F(value) 	    Reflect.construct(F, value) 	    [[Construct]]*/
let obj07 = {};
Reflect.set(obj07, 'a', 16);
console.log(obj07); // Object { a: 16 }

/*В частности, "Reflect" позволяет вызвать операторы, например, "new" или "delete", как функции ("Reflect.construct()",
"Reflect.deleteProperty()", и другие).*/

console.log('--------------------------------------');

/*-------------------------------------------------------------------------------------------------------------------*/

/*Для каждого внутреннего метода, перехватываемого "Proxy", есть соответствующий метод в "Reflect", который имеет такое
же имя и те же аргументы, что и у ловушки "Proxy". Поэтому мы можем использовать "Reflect", чтобы перенаправить 
операцию на исходный объект.*/

/*В этом примере обе ловушки "get" и "set" прозрачно (как будто их нет) перенаправляют операции чтения и записи на 
объект, при этом выводя сообщение.*/
let obj08 = { a: 17 };

obj08 = new Proxy(obj08, {

    get(target, property, receiver) {
        console.log(`GET ${property}`);
        return Reflect.get(target, property, receiver);
    },

    set(target, property, value, receiver) {
        console.log(`SET ${property}=${value}`);
        return Reflect.set(target, property, value, receiver);
    }

});

console.log(obj08.a); // 'GET a' -> 17
obj08.a = 18; // 'SET a=18'
console.log(obj08.a); // 'GET a' -> 18

console.log('--------------------------------------');

/*-------------------------------------------------------------------------------------------------------------------*/

/*В следующем примере мы ищем свойство "a" в объекте "obj10", затем в объекте "obj09Proxy", что триггерит ловушку 
"get". Эта ловушка обращается к оригинальному объекту "obj09", находит там свойство "a", в котором лежит геттер, и
вызывает этот геттер в рамках оригинального объекта "obj09". В итоге мы получаем 19, а не 20.*/
let obj09 = {
    _a: 19,

    get a() { return this._a; }
};

let obj09Proxy = new Proxy(obj09, {

    get(target, property, receiver) {
        console.log(receiver); // Object { _a: 20 }        
        return target[property];
    }

});

let obj10 = {
    __proto__: obj09Proxy,
    _a: 20
};

console.log(obj10.a); // 19

/*Сделаем исправленную версию. Здесь мы ищем свойство "a" в объекте "obj12", затем в объекте "obj11Proxy", что триггерит
ловушку "get". Эта ловушка обращается к оригинальному объекту "obj11", находит там свойство "a", в котором лежит геттер, и
вызывает этот геттер в рамках объекта "obj12". В итоге мы получаем 22.*/
let obj11 = {
    _a: 21,

    get a() { return this._a }
};

let obj11Proxy = new Proxy(obj11, {

    get(target, property, receiver) {
        console.log(receiver); // Object { _a: 22 }        
        return Reflect.get(target, property, receiver);
        // return Reflect.get(...arguments);
    }

});

let obj12 = {
    __proto__: obj11Proxy,
    _a: 22
};

console.log(obj12.a); // 22

console.log('--------------------------------------');

/*-------------------------------------------------------------------------------------------------------------------*/

/*Многие встроенные объекты, например "Map", "Set", "Date", "Promise" и другие используют так называемые "внутренние 
слоты". Это как свойства, но только для внутреннего использования в самой спецификации. Например, "Map" хранит 
элементы во внутреннем слоте "[[MapData]]". Встроенные методы обращаются к слотам напрямую, не через 
"[[Get]]"/"[[Set]]". Таким образом, прокси не может перехватить их. Если встроенный объект проксируется, то в прокси не
будет этих "внутренних слотов", так что попытка вызвать на таком прокси встроенный метод приведет к ошибке.

Внутри себя объект типа "Map" хранит все данные во внутреннем слоте "[[MapData]]". Прокси не имеет такого слота. 
Встроенный метод "Map.prototype.set()" пытается получить доступ к своему внутреннему свойству "this.[[MapData]]", но так
как this это "map01Proxy", то не может его найти и завершается с ошибкой.*/
let map01 = new Map();
let map01Proxy = new Proxy(map01, {});
// map01Proxy.set('a', 23); // Uncaught TypeError: set method called on incompatible Proxy

/*Сделаем исправленную версию. Сейчас все сработает, потому что "get" привязывает свойства-функции, такие как 
"map02.set()", к оригинальному объекту "map02". Таким образом, когда реализация метода "set" попытается получить доступ
к внутреннему слоту "this.[[MapData]]", то все пройдет благополучно.*/
let map02 = new Map();

let map02proxy = new Proxy(map02, {

    get(target, property) {
        let value = Reflect.get(target, property);
        // let value = Reflect.get(...arguments);
        console.log(value); // function set() -> function get()
        return typeof value === 'function' ? value.bind(target) : value;
    }

});

/*Чтобы вызвать метод "set()", мы должны его сначала получить, то есть затриггерить ловушку "get".*/
map02proxy.set('a', 24);
/*Чтобы вызвать метод "get()", мы должны его сначала получить, то есть затриггерить ловушку "get".*/
console.log(map02proxy.get('a')); // 24

/*Массивы не использует внутренние слоты.*/

console.log('--------------------------------------');

/*-------------------------------------------------------------------------------------------------------------------*/

/*В следующем примере приватные поля реализованы с использованием внутренних слотов, JavaScript не использует 
"[[Get]]"/"[[Set]]" при доступе к ним. В вызове "getA()" значением this является проксированный "obj13", в котором нет
внутреннего слота с приватными полями.*/
class Class01 {
    #a = 25;

    getA() { return this.#a };
};

let obj13 = new Class01();
obj13 = new Proxy(obj13, {});
// console.log(obj13.getA()); // Uncaught TypeError: can't access private field or method: object is not the right class

/*Сделаем исправленную версию опять при помощи привязки контекста к методу. Однако, такое решение имеет ряд недостатков:
методу передается оригинальный объект, который может быть передан куда-то еще, и это может поломать всю функциональность
проксирования.*/
class Class02 {
    #a = 26;

    getA() { return this.#a };
};

let obj14 = new Class02();

obj14 = new Proxy(obj14, {

    get(target, property) {
        let value = Reflect.get(target, property);
        // let value = Reflect.get(...arguments);
        console.log(value); // function getA()
        return typeof value === 'function' ? value.bind(target) : value;
    }

});

console.log(obj14.getA()); // 26

console.log('--------------------------------------');

/*-------------------------------------------------------------------------------------------------------------------*/

/*Прокси не перехватывают проверку на строгое равенство "===". Объект строго равен только самому себе, и никаким другим
значениям. Так что все операции и встроенные классы, которые используют строгую проверку объектов на равенство, отличат
прокси от изначального объекта. Прозрачной замены в данном случае не произойдет.*/

/*-------------------------------------------------------------------------------------------------------------------*/

/*Отключаемый (revocable) прокси - это прокси, который может быть отключен вызовом специальной функции.*/
let obj15 = { a: 27 };

let { proxy: obj15Proxy, revoke: revokeObj15Proxy } = Proxy.revocable(obj15, {});
console.log(obj15Proxy); // Proxy { <target>: {…}, <handler>: {} }
console.log(revokeObj15Proxy); // function ()

console.log(obj15Proxy.a); // 27

/*Вызов "revoke()" удаляет все внутренние ссылки на оригинальный объект из прокси, так что между ними больше нет связи,
и оригинальный объект теперь может быть очищен сборщиком мусора.*/
revokeObj15Proxy();
console.log(obj15Proxy); // Proxy { <target>: null, <handler>: null }
// console.log(obj15Proxy.a); // Uncaught TypeError: illegal operation attempted on a revoked proxy

console.log(obj15); // Object { a: 27 }

/*Мы можем хранить функцию "revoke()" в "WeakMap", чтобы легко найти ее по объекту прокси. Мы используем "WeakMap" вместо 
"Map", чтобы не блокировать сборку мусора. Если прокси объект становится недостижимым (то есть на него больше нет ссылок),
то "WeakMap" позволяет сборщику мусора удалить его из памяти вместе с соответствующей функцией "revoke()", которая в этом
случае больше не нужна.*/
let revokes = new WeakMap();
let obj16 = { a: 28 };
let { proxy: obj16Proxy, revoke: revokeObj16Proxy } = Proxy.revocable(obj16, {});
revokes.set(obj16Proxy, revokeObj16Proxy);

revokeObj16Proxy = revokes.get(obj16Proxy);
revokeObj16Proxy();

// console.log(obj16Proxy.a); // Uncaught TypeError: illegal operation attempted on a revoked proxy

/*-------------------------------------------------------------------------------------------------------------------*/

/*Конкретные показатели производительности прокси зависят от интерпретатора, но в целом получение свойства с помощью
простейшего прокси занимает в несколько раз больше времени. В реальности это имеет значение только для некоторых 
особо нагруженных объектов.*/