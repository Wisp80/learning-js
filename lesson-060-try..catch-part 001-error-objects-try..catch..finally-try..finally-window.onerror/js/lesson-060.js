'use strict';

/*-------------------------------------------------------------------------------------------------------------------*/

/*Синтаксическая конструкция "try..catch" позволяет перехватывать ошибки и вместо падения вскрипта делать что-то более 
осмысленное. Работает она так:
1) Сначала выполняется код внутри блока "try {...}".
2) Если в нем нет ошибок, то блок "catch(error)" игнорируется: выполнение доходит до конца блока "try {...}" и потом 
далее, полностью пропуская блок "catch(error)".
3) Если же в нем возникает ошибка, то выполнение блока "try {...}" прерывается, и поток управления переходит в начало
блока "catch(error)". Переменная "error" содержит объект ошибки с подробной информацией о произошедшем.*/
try {
    console.log('abc'); // "abc"
    null();
    console.log('def');
} catch (error) {
    console.log(error); // "TypeError: null is not a function"
};

console.log('ghi'); // "ghi"

console.log('--------------------------------------');

/*-------------------------------------------------------------------------------------------------------------------*/

/*Чтобы "try..catch" работал, код должен быть выполнимым. Другими словами, это должен быть корректный JavaScript-код. 
Он не сработает, если код синтаксически неверен, например, содержит несовпадающее количество фигурных скобок. 
Синтаксические ошибки проверяются перед запуской самого кода скрипта, поэтому код ниже вызовет ошибку до выполнения
рабочего кода сверху. JavaScript-движок сначала читает код, а затем исполняет его. Ошибки, которые возникают во время 
фазы чтения, называются ошибками парсинга. Их нельзя обработать (изнутри этого кода), потому что движок не понимает 
код. Таким образом, "try..catch" может обрабатывать только ошибки, которые возникают в корректном коде. Такие ошибки 
называют "ошибками во время выполнения", а иногда "исключениями".*/
// function name(params) {

/*-------------------------------------------------------------------------------------------------------------------*/

/*Когда возникает ошибка, JavaScript генерирует объект, содержащий ее детали. Затем этот объект передается как 
аргумент в блок "catch(error)". Для всех встроенных ошибок этот объект имеет два основных свойства:
1) "name" - имя ошибки. 
2) "message" - текстовое сообщение о деталях ошибки.

В большинстве окружений доступны и другие, нестандартные свойства. Одно из самых широко используемых и поддерживаемых 
это "stack". Это текущий стек вызова - строка, содержащая информацию о последовательности вложенных вызовов, которые 
привели к ошибке.*/
try {
    null();
} catch (error) {
    console.log(error);
    console.log(error.name); // "TypeError"
    console.log(error.message); // "null is not a function"
    console.log(error.stack);
};

console.log('--------------------------------------');

/*-------------------------------------------------------------------------------------------------------------------*/

/*Если нам не нужны детали ошибки, в блоке "catch(error)" можно ее пропустить.*/
try {
    null();
} catch {
    console.log('123'); // "123"
};

console.log('--------------------------------------');

/*-------------------------------------------------------------------------------------------------------------------*/

/*Оператор "throw" генерирует ошибку. В JavaScript есть множество встроенных конструкторов для стандартных ошибок: 
"Error()", "SyntaxError()", "ReferenceError()", "TypeError()" и другие. Их можно использовать для создания объектов 
ошибки. Для встроенных ошибок, свойство "name" – это в точности имя конструктора. А свойство "message" берется из 
аргумента.*/
let error01 = new ReferenceError('I am a reference error');

console.log(error01);
console.log(error01.name); // "ReferenceError"
console.log(error01.message); // "I am a reference error"
console.log(error01.stack);
console.log(' ');

let json01 = '{ "b": 2 }';

try {
    let obj01 = JSON.parse(json01);
    if (!obj01.a) { throw new SyntaxError('need "a"') };
} catch (error) {
    console.log(error);
};

console.log('--------------------------------------');

/*-------------------------------------------------------------------------------------------------------------------*/

/*Есть простое правило: блок "catch(error)" должен обрабатывать только те ошибки, которые ему известны, и 
"пробрасывать" все остальные.*/
let json02 = '{ "b": 2 }';

try {
    let obj01 = JSON.parse(json02);
    if (!obj01.a) { throw new SyntaxError('need "a"') };
    null();
} catch (error) {
    if (error.message === 'need "a"') {
        console.log('We have a JSON error');
    } else {
        try {
            throw error;
        } catch (error) {
            console.log(error);
        };
    };
};

console.log('--------------------------------------');

/*-------------------------------------------------------------------------------------------------------------------*/

/*Конструкция "try..catch" может содержать еще одну секцию: "finally". Если эта секция есть, то она выполняется в 
любом случае:
1) после "try", если не было ошибок
2) после "catch", если ошибки были.*/
try {
    console.log('a');
    null();
} catch (error) {
    console.log(error);
} finally {
    console.log('b');
};

/*Переменные внутри "try..catch..finally" локальны.*/

console.log('--------------------------------------');

/*-------------------------------------------------------------------------------------------------------------------*/

/*Блок "finally" срабатывает при любом выходе из" try..catch", в том числе и "return".*/
function func01() {
    try {
        return 1;
    } catch (error) {

    } finally {
        console.log(2);
    }
};

func01(); // 2

console.log('--------------------------------------');

/*-------------------------------------------------------------------------------------------------------------------*/

/*Можно использовать конструкцию "try..finally".*/
try {
    console.log(1); // 1
} finally {
    console.log(2); // 2
};

console.log('--------------------------------------');

/*-------------------------------------------------------------------------------------------------------------------*/

/*Такого способа нет в спецификации, но обычно окружения предоставляют способ перехватывать "глобальные" ошибки. 
Например, в Node.js для этого есть метод "process.on("uncaughtException")". А в браузере мы можем присвоить функцию 
специальному свойству "window.onerror", которая будет вызвана в случае необработанной ошибки.*/
window.onerror = function (message, url, line, col, error) {
    console.log(message); // "Script error."
    console.log(url);
    console.log(line); // 0
    console.log(col); // 0
    console.log(error); // undefined
};

a = 2;

/*Роль глобального обработчика "window.onerror" обычно заключается не в восстановлении выполнения скрипта – это скорее 
всего невозможно в случае программной ошибки, а в отправке сообщения об ошибке разработчикам.*/