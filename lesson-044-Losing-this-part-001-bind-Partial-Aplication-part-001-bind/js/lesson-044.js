'use strict';

/*-------------------------------------------------------------------------------------------------------------------*/

/*При передаче методов объекта в качестве колбэков, например для метода "setTimeout()", возникает проблема – потеря
контекста вызова this.*/
let obj01 = {
    method01() { console.log(this) }
};

/*Метод "setTimeout()" в браузере устанавливает this как глобальный объект Window для вызова функции. В Node.js this 
становится объектом таймера.*/
// setTimeout(obj01.method01, 500); // Window, а не "obj01"

console.log('--------------------------------------');

/*-------------------------------------------------------------------------------------------------------------------*/

/*Один из способов не терять this это использовать функцию-обертку.*/
let obj02 = {
    method01() { console.log(this) }
};

// setTimeout(function () { obj02.method01() }, 500); // "obj02"

console.log('--------------------------------------');

/*-------------------------------------------------------------------------------------------------------------------*/

/*Еще один способ не терять this это использовать встроенный метод функций "bind()". Этот метод в качестве параметра
принимает какой-то объект, который будет зафиксирован как контекст вызова this для указанной функции. Результатом 
вызова метода "bind()" является особый экзотический объект "bound function", который можно вызвать как функцию и этот 
объект при вызове прозрачно передает этот вызов в указанную функцию, при этом устанавливая контекст вызова this как 
объект переданный параметром в метод "bind()".*/
let obj03 = { a: 1 };
function func01() { console.log(this.a) };

let func01WithObj03 = func01.bind(obj03);
func01WithObj03(); // 1
func01WithObj03(); // 1
// func01(); // undefined, с "use strict" будет ошибка: Uncaught TypeError: this is undefined
console.log(typeof func01WithObj03); // function
console.log(func01WithObj03); // BoundFunctionObject { … }

console.log('--------------------------------------');

/*-------------------------------------------------------------------------------------------------------------------*/

/*Можно привязать не только this, но и аргументы при помощи метода "bind()". Все параметры кроме первого в методе 
"bind()" будут аргументами указанной функции.*/
function func02(a, b) { return a * b };

/*Это называется "частичное применение" – мы создаем новую функцию, фиксируя некоторые из существующих параметров.
Первый параметр "a" теперь всегда будет равен 2, а второй параметр придется указывать в момент вызова.*/
let func03 = func02.bind(null, 2);

console.log(func03(3)); // 2 * 3 = 6
console.log(func03(4)); // 2 * 4 = 8
console.log(func03(5)); // 2 * 5 = 10

console.log('--------------------------------------');

/*-------------------------------------------------------------------------------------------------------------------*/

/*Есть способ привязать аргументы, не привязывая this. Для этого мы не сможем использовать метод "bind()", так как он
не позволяет пропустить привязку this, но мы можем создать свою собственную функцию, например, для метода объекта.*/
function partial(func, ...argsBound) {
    // "func": один параметр функция (b, c) { console.log(`${this.a} ${b} ${c}`) }
    // "...argsBound": два параметра 'D' и 'E'
    return function (...args) {
        // "...args": два параметра 'B' и 'C'
        // В итоге 5 параметров, но последние два параметра 'B' и 'C' не будут использованы
        // this: obj04, так как obj04.method02()
        return func.call(this, ...argsBound, ...args);
    };
};

let obj04 = {
    a: 'A',
    method01(b, c) { console.log(`${this.a} ${b} ${c}`) }
};

obj04.method01('B', 'C'); // 'A B C'

/*Добавляем частично примененный метод с фиксированными двумя параметрами.*/
obj04.method02 = partial(obj04.method01, 'D', 'E');
obj04.method02('B', 'C'); // 'A D E'

console.log('--------------------------------------');

/*-------------------------------------------------------------------------------------------------------------------*/

/*Экзотический объект "bound function", возвращаемый при первом вызове "func04.bind(...)", запоминает контекст (и 
аргументы, если они были переданы) только во время создания. Следующий вызов метода "bind()" будет устанавливать 
контекст уже для этого объекта. Это ни на что не повлияет. Можно сделать новую привязку, но нельзя изменить 
существующую.*/
function func04() { console.log(this) };
func04 = func04.bind({ a: 1 }).bind({ b: 2 });
func04(); // { a: 1 }