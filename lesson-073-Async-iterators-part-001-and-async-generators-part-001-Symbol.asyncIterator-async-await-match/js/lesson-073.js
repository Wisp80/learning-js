'use strict';

/*-------------------------------------------------------------------------------------------------------------------*/

/*Чтобы создать асинхронный итератор нужно использовать символьный метод "Symbol.asyncIterator()".*/
let obj01 = {
    a: 1,
    b: 3
};

obj01[Symbol.asyncIterator] = function () { // Используем "Symbol.asyncIterator()" вместо "Symbol.iterator()"
    console.log('Symbol.asyncIterator01'); // вызовется только один раз.

    return {
        current: this.a, // 1 -> 2 -> 3 -> 4
        last: this.b, // 6

        async next() { // Используем async-функцию, чтобы использовать ключевое слово "await" внутри.
            console.log('next01'); // Вызовется 4 раза.

            await new Promise(resolve => setTimeout(resolve, 500)); // Имитируем паузу между каждым циклом.

            if (this.current <= this.last) {
                // async-функция обвернет возвращаемый результат в промис, поэтому используем "await" в "for..of".
                return { done: false, value: this.current++ };
            } else {
                console.log('--------------------------------------');
                return { done: true };
            };
        }
    };
};

(async () => { // Используем самовызывавющуюся async-функция, так как нам нужно использовать "await" в "for..of".

    for await (let value of obj01) { // "await" будет брать результат из завершенных промисов, возвращаемых методом "next()", и класть в переменную "value".
        console.log(value); // 1 -> 2 -> 3
    };

})();

/*Некоторый функционал в JS требует обычных синхронных итераторов и не работают с асинхронными. Например оператор
расширения "...".*/
// console.log([...obj01]); // Uncaught TypeError: obj01 is not iterable

/*-------------------------------------------------------------------------------------------------------------------*/

/*Чтобы создать асинхронный генератор нужно использовать ключевое слово "await".*/
async function* funcGen01(start, end) { // Используем async-функцию-генератор, чтобы использовать ключевое слово "await" внутри.
    for (let i = start; i <= end; i++) {
        await new Promise(resolve => setTimeout(resolve, 500)); // Имитируем паузу между каждым циклом.

        /*async-функция-генератор при вызове вернет генератор, у которого метод "next()" будет async-функцией, которая 
        будет обварачивать возвращаемый результат в промис, поэтому используем "await" в "for..of".*/
        yield i;
    };
};

setTimeout(() => {
    (async () => { // Используем самовызывавющуюся async-функция, так как нам нужно использовать "await" в "for..of".
        let gen01 = funcGen01(4, 6);

        for await (let value of gen01) { // "await" будет брать результат из завершенных промисов, возвращаемых async-генератором, и класть в переменную "value".
            console.log(value); // 4 -> 5 -> 6
        };

        console.log('--------------------------------------');
    })();
},
    2000);

/*-------------------------------------------------------------------------------------------------------------------*/

/*Можно создавать асинхронные итераторы-генераторы.*/
let obj02 = {
    a: 7,
    b: 9
};

obj02[Symbol.asyncIterator] = async function* () { // Используем async-функцию-генератор, чтобы использовать ключевое слово "await" внутри.
    for (let value = this.a; value <= this.b; value++) {
        await new Promise(resolve => setTimeout(resolve, 500)); // Имитируем паузу в 1 секунду между каждым циклом.

        /*async-функция-генератор при вызове вернет генератор, у которого метод "next()" будет async-функцией, которая 
        будет обварачивать возвращаемый результат в промис, поэтому используем "await" в "for..of".*/
        yield value;
    };
};

setTimeout(() => {
    (async () => { // Используем самовызывавющуюся async-функция, так как нам нужно использовать "await" в "for..of".

        for await (let value of obj02) {
            console.log(value); // 7 -> 8 -> 9
        };

        console.log('--------------------------------------');
    })();
},
    4000);

/*-------------------------------------------------------------------------------------------------------------------*/

/*Сделаем реальный пример использования асинхронной-функции-генератора.*/
async function* fetchCommits(repo) {
    /*Формируем ссылку на API Github, чтобы получать коммиты из какого-то репозитория. Github может присылать нам
    по 30 коммитов за один раз и ссылку на новую партию коммитов.*/
    let url = `https://api.github.com/repos/${repo}/commits`;

    while (url) { // Цикл "while" будет работать пока у нас есть ссылка на следующую страницу с данными
        /*Делаем запрос на API Github и ждем. После ответа результат промиса, который вернет метод "fetch()", кладем в
        переменную "response" при помощи ключевого слова "await".*/
        const response = await fetch(
            url,

            {
                headers: { 'User-Agent': 'Our script' }, // GitHub требует заголовок "user-agent".
            }
        );

        console.log(response);

        /*Вызываем метод "json()" для запроса самих коммитов и ждем ответа. После ответа результат промиса, который 
        вернет метод "json()", кладем в переменную "body" при помощи ключевого слова "await".*/
        const body = await response.json();
        console.log(body);

        /*Ссылка на следующую страницу находится в заголовках. Извлекаем ее. Метод "match()" возвращает получившиеся 
        совпадения при сопоставлении строки с регулярным выражением.*/
        let nextPage = response.headers.get('Link').match(/<(.*?)>; rel="next"/);
        console.log(nextPage);

        /*Если переменная "nextPage" равна null, то она переменная "url" становится равна null. В этом случае цикл 
        "while" больше не будет создавать новых циклов. Иначе переменная "nextPage" будет ссылаться на массив, где 
        вторым элементом будет ссылка на следующую порцию коммитов, и переменная "url" становится равна ей, что породит
        создание нового цикла для обработки новой ссылки на коммиты.*/
        url = nextPage && nextPage[1];
        console.log(url);

        for (let commit of body) { // Перебираем коммиты.
            yield commit;
        };

        await new Promise(resolve => setTimeout(resolve, 500)); // Имитируем паузу между каждым циклом.

        console.log('--------------------------------------');
    };
};

setTimeout(() => {
    (async () => { // Используем самовызывавющуюся async-функция, так как нам нужно использовать "await" в "for..of".
        for await (const commit of fetchCommits('Wisp80/learning-js')) { // Перебираем генератор.
            console.log(commit.commit.message);
        };
    })();
},
    6000);