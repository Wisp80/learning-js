'use strict';

/*-------------------------------------------------------------------------------------------------------------------*/

/*Чтобы создать промис нужно использовать встроенный конструктор "Promise()". В параметрах этого конструктора
нужно указать callback-функцию, которая называется "исполнитель/executor". Когда промис создается, исполнитель 
запускается автоматически. В исполнителе желательно указывать такой код, которому для получения результата необходимо
"длительное" время, например, запрос на сервер с целью получить какие-то данные. 

У исполнителя может быть два аргумента: "resolve" и "reject". Оба эти аргумента являются колбэками, которые 
предоставляет сам JavaScript. Внутри исполнителя мы должны вызвать один из этих аргументов. Если работа завершилась 
успешно, то мы должны вызвать "resolve(value)", где "value" является результатом работы. Если работа завершилась не
успешно, то мы должны вызвать "reject(error)", где "error" является объектом ошибки.

У промиса есть внутренние свойства, к которым у нас нет прямого доступа: 
1) "state" - вначале "pending" (ожидание), потом меняется на "fulfilled" (выполнено успешно) при вызове 
"resolve(value)" или на "rejected" (выполнено с ошибкой) при вызове "reject(error)".
2) "result" - вначале undefined, далее изменяется на "value" при вызове "resolve(value)" или на "error" при вызове 
"reject(error)". "error" можно указать любого типа, но промис все равно обвернет в объект ошибки, если эта ошибка не
была перехвачена.*/
let promise001 = new Promise(

    function (resolve, reject) {
        setTimeout(() => resolve('done 01'), 1000);
    }

);

console.log(promise001.state); // undefined, скрытое свойство
console.log(promise001.result); // undefined, скрытое свойство
console.log(promise001); // { <state>: "pending", <result>: undefined } => { <state>: "fulfilled", <result>: "done" }

let promise002 = new Promise(

    function (resolve, reject) {
        // setTimeout(() => reject('not done 01'), 1000);
    }

);

console.log(promise002);  // { <state>: "pending", <result>: undefined } => { <state>: "rejected", <result>: "not done" }

/*-------------------------------------------------------------------------------------------------------------------*/

/*Исполнитель должен вызвать что-то одно: "resolve()" или "reject()". Состояние промиса может быть изменено только 
один раз. Попытки вызвать дополнительно "resolve()" или "reject()" будут проигнорированы.*/

/*Желательно вызывать "reject()" с объектом "Error" или унаследованный от него.*/

/*-------------------------------------------------------------------------------------------------------------------*/

/*Промис служит связующим звеном между исполнителем и функциями-потребителями, которые получат либо результат, либо 
ошибку. Функции-потребители могут быть зарегистрированы (подписаны) с помощью методов "then()" и "catch()".*/

/*Первый аргумент метода "then()" - это функция, которая выполняется, когда промис переходит в состояние "fulfilled", 
и получает результат "value". Второй аргумент метода "then()" - это функция, которая выполняется, когда промис 
переходит в состояние "rejected", и получает ошибку "error".*/
let promise003 = new Promise(

    function (resolve, reject) {
        setTimeout(() => resolve('done 02'), 2000);
        // setTimeout(() => reject('not done 02'), 2000);
    }

);

promise003.then(
    result => console.log(result),
    error => console.log(error)
);

/*-------------------------------------------------------------------------------------------------------------------*/

/*Если мы хотели бы только обработать ошибку, то можно использовать null в качестве первого аргумента в методе "then()".
Или можно воспользоваться методом "catch()", который сделает то же самое.*/
let promise004 = new Promise(

    function (resolve, reject) {
        setTimeout(() => reject('not done 03'), 3000);
    }

);

promise004.catch(error => console.log(error));
promise004.catch(console.log);

/*-------------------------------------------------------------------------------------------------------------------*/

/*Также у промисов есть метод "finally()". Этот метод выполнится в любом случае, когда промис завершится: успешно или 
с ошибкой. Идея метода "finally()" состоит в том, чтобы настроить обработчик для выполнения очистки/доведения после 
завершения предыдущих операций. Например, остановка индикаторов загрузки, закрытие больше не нужных соединений и так 
далее.

Метод "finally()" в качестве параметра принимает callback-функцию. Эта функция, вызываемая из метода "finally()":
1) Не имеет аргументов, то есть не получает результат предыдущего обработчика.
2) "Пропускает" результат или ошибку дальше, к последующим обработчикам. 
3) Не должна ничего возвращать. Если это так, то возвращаемое значение игнорируется.*/
let promise005 = new Promise(

    (resolve, reject) => {
        setTimeout(() => resolve('done 04'), 4000);
        // setTimeout(() => reject('not done 04'), 4000);
    }

);

promise005
    .finally(() => console.log('promise005 has been finished'))
    .then(
        result => console.log(result),
        error => console.log(error)
    );

let promise006 = new Promise(

    (resolve, reject) => {
        setTimeout(() => reject('not done 05'), 5000);
    }

);

promise006
    .finally(() => console.log('promise006 has been finished'))
    .catch(error => console.log(error));

/*-------------------------------------------------------------------------------------------------------------------*/

/*Иногда может случиться так, что промис уже выполнен, когда мы добавляем к нему обработчик. В таком случае эти 
обработчики просто запускаются немедленно.*/
let promise007 = new Promise(resolve => resolve('done 06'));
promise007.then(console.log); // "done 06"

/*-------------------------------------------------------------------------------------------------------------------*/

/*Перепишем пример из предыдушего урока на промисах.*/
function loadScript01(src) {
    return new Promise(

        function (resolve, reject) {
            setTimeout(() => {
                let script = document.createElement('script');
                script.src = src;

                script.onload = () => resolve(script);
                script.onerror = () => reject(new Error(`${src} is not ready`));

                document.head.append(script);
            }, 6000)
        }

    );
};

let promise008 = loadScript01('https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.11/lodash.js');

promise008
    .then(
        script => console.log(`${script.src} is ready`),
        error => console.log(error.message)
    )
    .then(() => console.log(_));