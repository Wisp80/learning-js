'use strict';

/*-------------------------------------------------------------------------------------------------------------------*/

/*Ключевое слово "async" позволяет промисифицировать функцию.*/
async function func01() {
    return 1;
};

func01()
    .then(console.log) // 1

/*Можно и явно вернуть промис, результат будет одинаковым.*/
async function func02() {
    return Promise.resolve(2);
};

func02()
    .then(console.log) // 2

/*-------------------------------------------------------------------------------------------------------------------*/

/*Ключевое слово "await" заставит интерпретатор JavaScript ждать до тех пор, пока промис справа от "await" не 
выполнится. После чего оно вернет его результат, и выполнение кода продолжится. Ключевое слово "await" используется
только внутри async-функций.*/
async function func03() {
    let promise = new Promise(
        (resolve, reject) => {
            setTimeout(() => resolve('done'), 1000);
        }
    );

    let result = await promise; // Здесь код встает на 1 секунду.
    console.log(result); // Увидим "done" через 1 секунду.
};

func03()
    .then(console.log) // undefined

/*Хотя ключевое слово "await" и заставляет JavaScript дожидаться выполнения промиса, это не отнимает ресурсов 
процессора. Пока промис не выполнится, JS-движок может заниматься другими задачами: выполнять прочие скрипты, 
обрабатывать события и тому подобное.*/

/*-------------------------------------------------------------------------------------------------------------------*/

/*Если мы попробуем использовать ключевое слово "await" внутри функции, объявленной без ключевого "async", получим 
синтаксическую ошибку.*/
function func04() {
    let promise = Promise.resolve(1);
    // let result = await promise; // Uncaught SyntaxError: await is only valid in async functions, async generators and modules
};

func04();

/*-------------------------------------------------------------------------------------------------------------------*/

/*Ключевое слово "await" нельзя использовать на верхнем уровне вложенности.*/
let promise01 = new Promise(
    (resolve, reject) => {
        setTimeout(() => resolve(3), 1500);
    }
);

// let result01 = await promise01; // Uncaught SyntaxError: await is only valid in async functions, async generators and modules

/*Как вариант можно обернуть этот код в анонимную async–функцию.*/
(async () => {
    let result01 = await promise01;
    console.log(result01); // 3    
})();

/*-------------------------------------------------------------------------------------------------------------------*/

/*Ключевое слово "await" работает с "thenable"–объектами.*/
class Thenable {
    constructor(num) {
        this.num = num;
    };

    then(resolve, reject) {
        console.log(resolve); // function ()

        setTimeout(() => {
            resolve(this.num * 2);
            console.log(this); // Object { num: 4 }
        }, 2000);
    };
};

async function func05() {
    /*
    1. Создаем "thenable"–объект.
    2. Ключевое слово "await" воспринимает его как промис и вызывает у него метод "then()".
    3. Скорее всего, будет "на ходу" создан новый промис.
    4. Ждем 2 секунды до вызова метода "resolve()".
    5. Созданный промис резольвится и в качестве результата у него будет 8.
    6. Присваиваем этот результат переменной "result".*/
    let result = await new Thenable(4);
    console.log(result); // 8
};

func05();

/*Когда ключевое слово "await" получает объект с методом "then()", не являющийся промисом, JavaScript автоматически 
запускает этот метод, передавая ему аргументы - встроенные функции "resolve()" и "reject()". Затем ключевое слово 
"await" приостановит дальнейшее выполнение кода, пока любая из этих функций не будет вызвана. После чего выполнение 
кода продолжится с результатом работы функции "resolve()" или "reject()" соответственно.*/

/*-------------------------------------------------------------------------------------------------------------------*/

/*При помощи ключевого слова "await" можно обрабатывать ошибки.*/
async function func06() {
    try {
        let promise01 = new Promise(
            (resolve, reject) => {
                setTimeout(() => reject(new Error('error01')), 2000);
            }
        );

        let result = await promise01;
    } catch (error) {
        console.log(error); // TypeError: failed to fetch
    }
};

func06();

/*-------------------------------------------------------------------------------------------------------------------*/

/*async-функции могут возвращать зареджекшенный промис.*/
async function func07() {
    return Promise.reject(new Error('error02'));
};

func07()
    .catch(
        (error) => {
            console.log(error);
        }
    );