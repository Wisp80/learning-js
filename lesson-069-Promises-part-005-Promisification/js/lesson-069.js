'use strict';

/*-------------------------------------------------------------------------------------------------------------------*/

/*Промисификация - это преобразование функции, которая принимает callback-функцию, в функцию, которая вместо этого 
возвращает промис.*/
let src = 'https://';

let callback01 = (error, script) => {
    if (error) {
        console.log(error);
    } else {
        console.log(`${script.src} is ready`);
    };
};

/*Создадим функцию для промисификации.*/
function loadScript(src, callback) {
    let script = document.createElement('script');
    script.src = src;

    script.onload = () => callback(null, script);
    script.onerror = () => callback(new Error(`Ошибка загрузки скрипта ${src}`));

    document.head.append(script);
};

/*Использование функции "loadScript()".*/
// loadScript(src, callback01);

/*Промисифицируем функцию выше. Эта функция работает на основе функции выше, но теперь возвращает промис.*/
let loadScriptPromise01 = function (src) {
    return new Promise( // Главная цель этой функции вернуть промис.

        (resolve, reject) => { // Опишем функцию промиса.

            /*Поскольку функция "loadScript()" принимает два параметра и второй параметр это callback-функция, тогда
            создадим локальную callback-функцию, которая будет использоваться как второй параметр в вызове функции
            "loadScript()". Эта локальная callback-функция будет резольвить или реджектить промис.*/
            let callbackFunc = (error, script) => {

                if (error) {
                    reject(error);
                } else {
                    resolve(script);
                };

            };

            /*Вызываем оригинальную функцию "loadScript()", с нашей локальной callback-функцией.*/
            loadScript(src, callbackFunc);
        }

    )
};

/*Использование функци "loadScriptPromise01()".*/
// loadScriptPromise01(src);

/*Сделаем специальную вспомогательную функцию, которая будет создавать промисифицированную функцию на основе обычной
функции.*/
function promisify01(func) {
    /*Главная цель этой функции вернуть промисифицированную функцию-обертку над обычной функцией. Все переданные 
    параметры в эту функцию-обертку окажутся в массиве "args".*/
    return function (...args) {
        return new Promise( // Главная цель возвращенной функции будет вернуть промис. 

            (resolve, reject) => {

                /*Создаем такую же локальную callback-функцию, как и выше.*/
                function callback(error, result) {

                    if (error) {
                        reject(error);
                    } else {
                        resolve(result);
                    };

                };

                args.push(callback); // Нашу созданную локальную callback-функцию добавляем в массив аргументов "args". ( [ src, callback ] )
                func.call(this, ...args); // Вызываем оригинальную функцию в рамках текущего контекста this и параметрами из массива "args".

            }

        );
    };
};

/*Использование функции "promisify01()".*/
let loadScriptPromise02 = promisify01(loadScript);
// loadScriptPromise02(src);

/*Улучшим вспомогательную функцию выше, чтобы можно было промисифицировать функции не только с двумя параметрами. 
Вторым параметром нужно передовать флаг, обозначающий требуется ли много параметров для функции для промисификации.
Например, наша функция принимает три параметра: "src", "src", "callback".*/
function promisify02(func, manyArgs = false) {
    /*Главная цель этой функции вернуть промисифицированную функцию-обертка над обычной функцией. Все переданные 
    параметры в эту функцию-обертку окажутся в массиве "args".*/
    return function (...args) {
        return new Promise( // Главная цель возвращенной функции будет вернуть промис.

            (resolve, reject) => {

                /*Создаем почти такую же локальную callback-функцию, как и выше, но теперь, когда резольвим функцию, то
                обращаем внимание на флаг "manyArgs". Если параметров много, то резольвим промис со всеми ними, если же
                параметров не много, то резольвим промис только с первым параметром из массива "results".*/
                function callback(error, ...results) { // Все параметры кроме первого попадут в массив "results".

                    if (error) {
                        reject(error);
                    } else {
                        resolve(manyArgs ? results : results[0]);
                    };

                };

                args.push(callback); // нашу созданную локальную callback-функцию добавляем в массив аргументов "args". ( [ src, src , callback ] )
                func.call(this, ...args); // вызываем оригинальную функцию в рамках текущего контекста this и параметрами из массива "args".

            }

        );
    };
};

/*Использование функции "promisify02()".*/
let loadScriptPromise03 = promisify02(loadScript, true);
// loadScriptPromise03(src, src);

/*Промисификация не является тотальной заменой любых callback-функций. Промис может иметь только один результат, но 
callback-функция технически может вызываться сколько угодно раз. Поэтому промисификация используется для функций, 
которые вызывают callback-функцию только один раз. Последующие вызовы callback-функции будут проигнорированы.*/